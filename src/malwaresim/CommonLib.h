
#ifndef COMMONLIB_H
#define COMMONLIB_H

#include "MalwareStrength.h"
#include "Port.h"
#include "Device.h"
#include "Network.h"

#include <iostream>

using std::cout;
using std::endl;

enum CommandType {
    NETWORK_NEW,
    PERSONAL_NEW,
    FIREWALL_NEW,
    CONNECTION_IS,
    INFECTION_IS,
    INFECTED_DEL,
    CLONE,
    CLONE_ALL,
    RATING_IS,
    NOP, // Empty command line. NOP stands for No Operation
    INVALID_COMMAND
};

bool isPersonalDevice(const Ptr<Device>& device) {
    return (dynamic_cast<PersonalDevice*>(device.ptr()) != null);
}

bool isFirewallDevice(const Ptr<Device>& device) {
    return (dynamic_cast<FirewallDevice*>(device.ptr()) != null);
}

bool isInfected(const Ptr<Device>& device) {
    return device->health() == "infected";
}

void cloneAllPortRatings(const Ptr<Device> parentDevice, const Ptr<Device> clonedDevice) {
    for (auto p = 0u; p < parentDevice->portCount(); p++) {
        clonedDevice->portRatingIs(p, parentDevice->port(p).rating());
    }
}

bool deviceExists(const Ptr<Network> network, const string& deviceName) {
    return (network->device(deviceName));
}

bool connectedPort(const Ptr<Device> device, const U32 p) {
    return !(device->availablePort(p));
}

void disconnectAllPorts(const Ptr<Device> device) {
    for (auto i = 0u; i < device->portCount(); i++) {
        device->availablePortIsTrue(i);
    }
}

void printInvalidCommand(const string& cmd, const string& error) {
    cout << "[WARNING]: " << error << endl;
    cout << "[WARNING]: Invalid command: '" << cmd << "'. Skipping" << endl;
}

template<class T>
void printIfNullOrNot(const Ptr<T> ptr, const string& prefix) {
    if (ptr) {
        cout << prefix << " => not null" << endl;
    } else {
        cout << prefix << " => NULL!" << endl;
    }
}

void printNetworkStatistics(const Ptr<Network> network) {
    const auto space = "     ";
    cout << "==========================================================================" << endl;
    cout << "Statistics for network '" << network->name() << "'" << endl;
    cout << "==========================================================================" << endl;
    cout << "Devices: " << endl;
    for (auto it = network->deviceIter(); it != network->deviceIterEnd(); it++) {
        cout << space << it->first << endl;
    }

    cout << endl;

    cout << "Connections:" << endl;
    for (auto it = network->deviceIter(); it != network->deviceIterEnd(); it++) {
        auto deviceName = it->first;
        auto device = it->second;
        for (auto i = 0; i < device->portCount(); i++) {
            if (!device->availablePort(i)) {
                auto port = device->port(i);
                auto otherDevice = port.otherDevice();
                auto otherPort = port.otherPort();
                cout << space 
                     << device->name() << "[" << i << "] is { " 
                     << port.rating().value() 
                     << ", " << otherDevice->name() << "[" << otherPort << "] }"
                     << endl;
            }
        }

        cout << endl;
    }

    cout << "==========================================================================" << endl << endl;
}

string getCommandType(CommandType type) {
    switch(type) {
        case NETWORK_NEW: return "NETWORK_NEW";
        case PERSONAL_NEW: return "PERSONAL_NEW";
        case FIREWALL_NEW: return "FIREWALL_NEW";
        case CONNECTION_IS: return "CONNECTION_IS";
        case INFECTION_IS: return "INFECTION_IS";
        case INFECTED_DEL: return "INFECTED_DEL";
        case CLONE: return "CLONE";
        case CLONE_ALL: return "CLONE_ALL";
        case RATING_IS: return "RATING_IS";
        case INVALID_COMMAND: return "INVALID_COMMAND";
        case NOP: return "NOP";
        default:
            cout << "[WARNING]: Unexpected type of command" << endl;
            return "UNEXPECTED_COMMAND_TYPE";
    }
}

#endif