
#ifndef COMMONLIB_H
#define COMMONLIB_H

#include "MalwareStrength.h"
#include "Port.h"
#include "Device.h"
#include "Network.h"

#include <iostream>

using std::cerr;
using std::cout;
using std::endl;

enum CommandType {
    NETWORK_NEW,
    PERSONAL_NEW,
    FIREWALL_NEW,
    CONNECTION_IS,
    INFECTION_IS,
    INFECTED_DEL,
    CLONE,
    CLONE_ALL,
    RATING_IS,
    NOP, // Empty command line. NOP stands for No Operation
    INVALID_COMMAND
};

enum ErrorLevel {
    WARNING,
    ERROR
};

struct InfectionStats {
    unsigned int attacked = 0;
    double relativeStrength = 0.0;
    unsigned int longestPath = 0;
};

struct AttackTarget {
    Ptr<Device> device = null;
    U32 port = 0;
    U32 numHopsFromOriginOfAttack = 0;

    AttackTarget(Ptr<Device> d, U32 p, U32 n):
        device(d),
        port(p),
        numHopsFromOriginOfAttack(n) {}
};

bool isPersonalDevice(const Ptr<Device>& device) {
    return (dynamic_cast<PersonalDevice*>(device.ptr()) != null);
}

bool isFirewallDevice(const Ptr<Device>& device) {
    return (dynamic_cast<FirewallDevice*>(device.ptr()) != null);
}

bool isInfected(const Ptr<Device>& device) {
    return device->health() == "infected";
}

void cloneAllPortRatings(const Ptr<Device> parentDevice, const Ptr<Device> clonedDevice) {
    for (auto p = 0u; p < parentDevice->portCount(); p++) {
        clonedDevice->portRatingIs(p, parentDevice->port(p).rating());
    }
}

bool connectedPort(const Ptr<Device> device, const U32 p) {
    return !(device->availablePort(p));
}

void disconnectAllPorts(const Ptr<Device> device) {
    for (auto i = 0u; i < device->portCount(); i++) {
        device->availablePortIsTrue(i);
    }
}

void logError(ErrorLevel errorLevel, const string& err) {
    switch(errorLevel) {
        case WARNING: 
            cerr << "[WARNING]: " << err << endl;
            break;
        case ERROR:
            cerr << "[ERROR]: " << err << endl;
            break;
        default:
            cerr << "[INTERNAL ERROR]: Unexpected error level: " << errorLevel << endl;
    }
}

#endif
