
#ifndef SYSTEM_H
#define SYSTEM_H

#include "fwk/fwk.h"

#include "MalwareStrength.h"
#include "Port.h"
#include "Device.h"
#include "Network.h"
#include "CommonLib.h"

#include <iostream>
#include <fstream>
#include <sstream>
#include <queue>
#include <regex>
#include <set>
#include <tuple>
#include <unordered_map>
#include <utility>
#include <vector>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ifstream;
using std::ostream;
using std::stringstream;

using std::queue;
using std::unordered_map;
using std::vector;

using std::to_string;

using std::list;
using std::make_pair;
using std::make_tuple;
using std::pair;
using std::regex;
using std::regex_match;
using std::set;
using std::smatch;
using std::stod;
using std::stoi;
using std::tuple;

using fwk::BaseNotifiee;
using fwk::NamedInterface;
using fwk::NotifierLib::post;
using fwk::Ptr;

class NetworkTracker;

class DeviceTracker : public Device::Notifiee {
public:
    static DeviceTracker* instanceNew() {
        return new DeviceTracker();
    }

    void networkTrackerIs(const Ptr<NetworkTracker>& networkTracker);
    virtual void onHealth();

private:
    friend class NetworkTracker;

    Ptr<NetworkTracker> networkTracker_;   
};

class NetworkTracker : public Network::Notifiee {
public:
    NetworkTracker() : 
        personalDeviceCount_(0),
        firewallDeviceCount_(0),
        infectedDeviceCount_(0) {
        // Nothing to do
    }

    //static NetworkTracker* instanceNew() {
    static Ptr<NetworkTracker> instanceNew() {
        return new NetworkTracker();
    }

    // TODO: Does this method need to be 'virtual'?
    virtual void onDeviceNew(const Ptr<Device>& device) { 
        addDevice(device);
        changeDeviceCount(device, true);
    }

    // TODO: Does this method need to be 'virtual'?
    virtual void onDeviceDel(const Ptr<Device>&  device) {
        changeDeviceCount(device, false);
        if (isInfected(device)) {
            infectedDeviceCount_--;
        }
    }

    void onDeviceHealth(const Ptr<Device>& device) {
        auto delta = isInfected(device) ? 1 : -1;
        infectedDeviceCount_ += delta;
    }

    unsigned int personalDeviceCount() {
        return personalDeviceCount_;
    }

    unsigned int firewallDeviceCount() {
        return firewallDeviceCount_;
    }

    unsigned int infectedDeviceCount() {
        return infectedDeviceCount_;
    }

private:
    unsigned int personalDeviceCount_;
    unsigned int firewallDeviceCount_;
    unsigned int infectedDeviceCount_;

    // TODO: Rename function and 'inc' parameter? Should we use a boolean param or use an enum {NEW, DEL}
    void changeDeviceCount(const Ptr<Device>&  device, bool inc) {
        auto delta = inc ? 1 : -1;
        if (isPersonalDevice(device)) {
            personalDeviceCount_ += delta;   
        } else if (isFirewallDevice(device)) {
            firewallDeviceCount_ += delta;
        } else {
        	cout << "[WARNING]: changeDeviceCount(): Unexpected type of device" << endl;
        }
    }

    void addDevice(const Ptr<Device>& device) {
        // TODO: When deviceTracker is of type Ptr<DeviceTracker>, the run ends in seg fault. Why? (It works when the type is DeviceTracker* instead)
        //const Ptr<DeviceTracker> deviceTracker = DeviceTracker::instanceNew();
        const auto deviceTracker = DeviceTracker::instanceNew();
        deviceTracker->notifierIs(device);
        deviceTracker->networkTrackerIs(this);
    }
};

void DeviceTracker::networkTrackerIs(const Ptr<NetworkTracker>& networkTracker) {
    networkTracker_ = networkTracker;
}

void DeviceTracker::onHealth() {
    networkTracker_->onDeviceHealth(notifier());
} 

//TODO:
// (i) The warning messages should be sent to stderr not stdout

class System : public NamedInterface {
public:
	typedef unordered_map< string, Ptr<Network> > NetworkMap;
    typedef unordered_map< string, Ptr<NetworkTracker> > NetworkTrackerMap;
    typedef tuple< Ptr<Device>, U32, U32 > AttackTarget;

	static Ptr<System> instanceNew(string name) {
        return new System(name);
    }

    System(const string& name) :
    	NamedInterface(name)
	{
		//Nothing to do
	}

    // TODO: Throw an exception or warning if a network with the given name has not been instantiated
    Ptr<Network> network(const string& name) {
    	auto it = networkMap_.find(name);
    	if (it != networkMap_.end()) {
    		return it->second;	
    	}
        
        return null;
    }

    Ptr<NetworkTracker> networkTracker(const string& name) {
        auto it = networkTrackerMap_.find(name);
        if (it != networkTrackerMap_.end()) {
            return it->second;  
        }
        
        return null;
    }

    // Executes a networkNew command
    Ptr<Network> networkNew(const string& name) { 
        if (networkMap_.find(name) == networkMap_.end()) {
            auto network = Network::instanceNew(name);
            auto notifiee = NetworkTracker::instanceNew();
            notifiee->notifierIs(network);
            networkMap_.insert(NetworkMap::value_type(name, network));
            networkTrackerMap_.insert(NetworkTrackerMap::value_type(name, notifiee));
            return network;
        } 
        
        cout << "[WARNING]: A network with the same name '" << name << "' already exists. Skipping." << endl;
        return null;
    }

    // Executes a personalNew command
    Ptr<Device> personalNew(const string& networkName, const string& deviceName) { 
        auto device = PersonalDevice::instanceNew(deviceName);
        auto n = network(networkName); // TODO: Rename this variable
        try {
            n->deviceIs(device);
            return device;
        } catch (const fwk::NameInUseException& e) {
            cout << "WARNING: PersonalDevice '" << deviceName << "' already in use in network '" << networkName << "'" << endl;
        }

        return null;
    }

    // Executes a firewallNew command
    Ptr<Device> firewallNew(const string& networkName, const string& deviceName) { 
        auto device = FirewallDevice::instanceNew(deviceName);
        auto n = network(networkName);
        try {
            n->deviceIs(device); // TODO: Rename this variable
            return device;
        } catch (const fwk::NameInUseException& e) {
            cout << "WARNING: FirewallDevice '" << deviceName << "' already in use in network '" << networkName << "'" << endl;
        }

        return null;
    }

    // Executes a connectionIs command
    void connectionIs(const string& networkName, 
                      const string& device1Name, 
                      const U32 p1, 
                      const string& device2Name, 
                      const U32 p2) { 
        if (device1Name != device2Name) {
            auto n = network(networkName); // TODO: Rename this variable
            auto device1 = n->device(device1Name); // TODO: Check if returned device is null, ie, such a device has not been instantiated
            auto device2 = n->device(device2Name);
            if ((device1->availablePort(p1)) && (device2->availablePort(p2))) {
                device1->connectionIs(p1, device2, p2);
            } else {
                cout << "[WARNING]: Skpping connectionIs command since either sourcePort ('" << device1Name << "," << p1 
                     << "') or destinationPort ('" << device2Name << "," << p2
                     << "') (or both) are already in use." << endl;
            }
        } else {
            cout << "[WARNING]: connectionIs cannot connect ports of the same device ('" << device1Name << "') to each other. Skipping." << endl;
        }
    }

    AttackTarget computeOriginOfAttack(const Ptr<Device> device, const vector<U32> ports) {
        Ptr<Device> startDevice;
        if (ports.size() == 1) {
            return make_tuple(device, ports.front(), 1);
        } else {
            startDevice = device;
            for (auto i = 0; i < ports.size() - 1; i++) {
                auto p = ports[i];
                if (connectedPort(startDevice, p)) {
                    auto port = startDevice->port(p);
                    startDevice = port.otherDevice();
                } else {
                	cout << "[WARNING]: infectionIs(): The given sequence of ports do not form a connected sequence. Skipping command." << endl;
                	return make_tuple(null, 0, 0);
                }
            }
        }

        auto startPort = ports.back();
        return make_tuple(startDevice, startPort, 1);
    }

    // TODO: Refactor the code in this function and the 'infectDevice' method
    // Could abstract AttackTarget as a class
    void infectionIs(const string& networkName,
                     const MalwareStrength& infectionStrength,
                     const string& deviceName,
                     const vector<U32> ports) {
        auto n = network(networkName); // TODO: Rename this variable

        auto device = n->device(deviceName); // TODO: Check if returned device is null, ie, such a device has not been instantiated
        queue<AttackTarget> targetsToAttack;
        set<string> devicesAttacked;
        auto longestPath = 0;
        auto relativeStrength = 0.0;

        AttackTarget originOfAttack = computeOriginOfAttack(device, ports);
        if (std::get<0>(originOfAttack) == null) {
            cout << "[WARNING]: Skipping infectionIs command. Could not determine the device and port to start the attack from" << endl;
        	return;
        }
        
        targetsToAttack.push(originOfAttack);

        while (!targetsToAttack.empty()) {
            auto attackTarget = targetsToAttack.front();
            targetsToAttack.pop();
            auto device = std::get<0>(attackTarget);
            if (!isInfected(device)) {
                auto port = std::get<1>(attackTarget);
                auto numHopsFromOriginOfAttack = std::get<2>(attackTarget);
                auto attackSuccessful = infectDevice(device, port, infectionStrength, numHopsFromOriginOfAttack, &targetsToAttack);
                if ((attackSuccessful) && (numHopsFromOriginOfAttack > longestPath)) {
                    longestPath = numHopsFromOriginOfAttack;
                }

                devicesAttacked.insert(device->name());
                relativeStrength += infectionStrength - device->port(port).rating();
            }
        }

        auto tracker = networkTracker(networkName);
        //printStatisticsForInfectionIsCmd(n, devicesAttacked.size(), relativeStrength, longestPath);
        printStatisticsForInfectionIsCmd(tracker, devicesAttacked.size(), relativeStrength, longestPath);
    }

    bool infectDevice(const Ptr<Device>& device,
                      const U32 portId, 
                      const MalwareStrength& infectionStrength,
                      const U32 numHopsFromOriginOfAttack,
                      queue<AttackTarget>* targetsToAttack) {
        auto port = device->port(portId);
        if (port.rating() >= infectionStrength) { // The infection fails immediately
            return false; 
        }

        device->healthIs("infected");
        for (U32 i = 0; i < device->portCount(); i++) {
            if (connectedPort(device, i)) {
                auto port = device->port(i);
                auto otherDevice = port.otherDevice();
                if (!isInfected(otherDevice)) {
                    AttackTarget p = make_tuple(port.otherDevice(), port.otherPort(), numHopsFromOriginOfAttack + 1);
                    targetsToAttack->push(p);
                }
            }
        }

        return true;
    }

    void infectedDel(const string& networkName) {
        auto n = network(networkName); // TODO: Rename this variable
        vector<Ptr<Device>> devicesToDelete;

        for (auto it = n->deviceIter(); it != n->deviceIterEnd(); it++) {
            auto device = it->second;
            if (isInfected(device)) {
                devicesToDelete.push_back(device);
            }
        }

        for (auto it = devicesToDelete.cbegin(); it != devicesToDelete.cend(); it++) {
            auto device = *it;
            disconnectAllPorts(device);
            n->deviceDel(device->name());
        }
    }

    Ptr<Device> clone(const string& networkName,
               const string& device1Name,
               const U32 device1Port,
               const string& device2Name,
               const U32 device2Port) {
        auto n = this->network(networkName); // TODO: Rename this variable
        auto device1 = n->device(device1Name);

        if (device1->availablePort(device1Port)) {
            Ptr<Device> device2;
            if (isPersonalDevice(device1)) {
                device2 = PersonalDevice::instanceNew(device2Name);
            } else if (isFirewallDevice(device1)) {
                device2 = FirewallDevice::instanceNew(device2Name);
            } else {
            	cout << "[WARNING]: clone(): Unexpected type of device" << endl;
            	return null;
            }

            n->deviceIs(device2);
            device2->healthIs(device1->health());
            cloneAllPortRatings(device1, device2);
            device1->connectionIs(device1Port, device2, device2Port);

            return device2;
        } 
        
        // TODO: Ignore the command and return a warning. 
        return null;
    }

    // TODO: Refactor this function
    void cloneAll(const string& networkName,
                  const U32 p1,
                  const U32 p2) {
        auto n = network(networkName);
        unordered_map< string, Ptr<Device> > parentNameToClone;
        std::list< string > parentDeviceNames;

        for (auto it = n->deviceIter(); it != n->deviceIterEnd(); it++) {
            parentDeviceNames.push_back(it->first);
        }        

        for (auto it = parentDeviceNames.cbegin(); it != parentDeviceNames.cend(); it++) {
            const auto parentName = *it;
            auto cloneName = parentName + "-" + to_string(p1);
            if (!deviceExists(n, cloneName)) {
                auto clonedDevice = clone(networkName, parentName, p1, cloneName, p2);
                if (clonedDevice) { // Cloning was successful
                    parentNameToClone[parentName] = clonedDevice;
                } else {
                    // TOOD: Print warning
                }
            } else {
                // TOOD: Print warning that a device of that name already exists. Hence, not cloning parent.
            }
        }

        for (auto it = parentNameToClone.cbegin(); it != parentNameToClone.cend(); it++) {
            auto parent = n->device(it->first);
            auto clonedDevice = it->second;

            for (int p3 = 0; p3 < parent->portCount(); p3++) {
                if ((p3 != p1) && (!parent->availablePort(p3))) { // Port 'p1' of the parent is already in use. Its been connected to the clone
                    auto parentPort = parent->port(p3);

                    auto otherDevice = parentPort.otherDevice();
                    auto tmp = parentNameToClone.find(otherDevice->name());
                    if (tmp != parentNameToClone.end()) {
                        auto otherClone = tmp->second;
                        auto p4 = parentPort.otherPort();
                        
                        if (clonedDevice->availablePort(p3) && otherClone->availablePort(p4)) {
                            clonedDevice->connectionIs(p3, otherClone, p4);
                        } else {
                            // TODO: Print warning and skip this connection
                        }
                    }
                }
            }
        }       
    }

    void ratingIs(const string& networkName,
                  const string& deviceName,
                  const U32 p,
                  const MalwareStrength& rating) {
        auto n = network(networkName);
        auto device = n->device(deviceName);
        device->portRatingIs(p, rating);
    }

private:
    NetworkMap networkMap_;
    NetworkTrackerMap networkTrackerMap_;

    void printStatisticsForInfectionIsCmd(const Ptr<NetworkTracker> networkTracker, 
                                          const int numDevicesAttacked, 
                                          const double relativeStrength, 
                                          const int longestPath) {
        auto space = " ";
        cout << ""    << networkTracker->infectedDeviceCount()
             << space << numDevicesAttacked
             << space << relativeStrength
             << space << networkTracker->personalDeviceCount()
             << space << networkTracker->firewallDeviceCount()
             << space << longestPath
             << endl;
    }
};

#endif