
#ifndef SYSTEM_H
#define SYSTEM_H

#include "fwk/fwk.h"

#include "MalwareStrength.h"
#include "Port.h"
#include "Device.h"
#include "Network.h"
#include "CommonLib.h"

#include <iostream>
#include <fstream>
#include <sstream>
#include <queue>
#include <unordered_map>
#include <utility>
#include <vector>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ifstream;
using std::ostream;
using std::stringstream;

using std::queue;
using std::unordered_map;
using std::vector;

using std::list;
using std::to_string;
using std::tuple;

using fwk::BaseNotifiee;
using fwk::NamedInterface;
using fwk::NotifierLib::post;
using fwk::Ptr;

class NetworkTracker;

class DeviceTracker : public Device::Notifiee {
public:
    static DeviceTracker* instanceNew() {
        return new DeviceTracker();
    }

    void networkTrackerIs(const Ptr<NetworkTracker>& networkTracker);
    virtual void onHealth();

private:
    friend class NetworkTracker;

    Ptr<NetworkTracker> networkTracker_;   
};

class NetworkTracker : public Network::Notifiee {
public:
    NetworkTracker() : 
        personalDeviceCount_(0),
        firewallDeviceCount_(0),
        infectedDeviceCount_(0) {
        // Nothing else to do
    }

    static Ptr<NetworkTracker> instanceNew() {
        return new NetworkTracker();
    }

    virtual void onDeviceNew(const Ptr<Device>& device) { 
        addDevice(device);
        changeDeviceCount(device, true);
    }

    virtual void onDeviceDel(const Ptr<Device>&  device) {
        changeDeviceCount(device, false);
        if (isInfected(device)) {
            infectedDeviceCount_--;
        }

        auto deviceTracker = deviceToTracker_[device->name()];
        delete deviceTracker;
        deviceToTracker_.erase(device->name());
    }

    void onDeviceHealth(const Ptr<Device>& device) {
        auto delta = isInfected(device) ? 1 : -1;
        infectedDeviceCount_ += delta;
    }

    unsigned int personalDeviceCount() {
        return personalDeviceCount_;
    }

    unsigned int firewallDeviceCount() {
        return firewallDeviceCount_;
    }

    unsigned int infectedDeviceCount() {
        return infectedDeviceCount_;
    }

private:
    unsigned int personalDeviceCount_;
    unsigned int firewallDeviceCount_;
    unsigned int infectedDeviceCount_;
    unordered_map< string, DeviceTracker* > deviceToTracker_;

    /* Updates the device count in the network. 
       Based on 'inc', the device count is either incremented or decremented
    */
    void changeDeviceCount(const Ptr<Device>&  device, bool inc) {
        auto delta = inc ? 1 : -1;
        if (isPersonalDevice(device)) {
            personalDeviceCount_ += delta;   
        } else if (isFirewallDevice(device)) {
            firewallDeviceCount_ += delta;
        } else {
        	cout << "[WARNING]: changeDeviceCount(): Unexpected type of device" << endl;
        }
    }

    void addDevice(const Ptr<Device>& device) {
        const auto deviceTracker = DeviceTracker::instanceNew();
        deviceTracker->notifierIs(device);
        deviceTracker->networkTrackerIs(this);
        deviceToTracker_[device->name()] = deviceTracker;
    }
};

void DeviceTracker::networkTrackerIs(const Ptr<NetworkTracker>& networkTracker) {
    networkTracker_ = networkTracker;
}

void DeviceTracker::onHealth() {
    networkTracker_->onDeviceHealth(notifier());
} 

/*
========================================================================================
    This class encapsulates the core logic of the application.
    It maintains the entire state of a simulation such as the list of networks, etc.
    Moreover, it exposes a public method corresponding to each of the 9 types of commands.
    The MalwareSim class creates an instance of this class and uses these methods to run 
    the simulation.

    Each command's return value indicates whether the command was run successfully or not
==========================================================================================
*/

class System : public NamedInterface {
public:
	typedef unordered_map< string, Ptr<Network> > NetworkMap;
    typedef unordered_map< string, Ptr<NetworkTracker> > NetworkTrackerMap;

	static Ptr<System> instanceNew(string name) {
        return new System(name);
    }

    System(const string& name) :
    	NamedInterface(name)
	{
		//Nothing to do
	}

    Ptr<Network> network(const string& name) {
    	auto it = networkMap_.find(name);
    	if (it != networkMap_.end()) {
    		return it->second;	
    	}
        
        return null;
    }

    Ptr<NetworkTracker> networkTracker(const string& name) {
        auto it = networkTrackerMap_.find(name);
        if (it != networkTrackerMap_.end()) {
            return it->second;  
        }
        
        return null;
    }

    // Executes a networkNew command
    Ptr<Network> networkNew(const string& name) { 
        if (verifyNetworkNewParameters(name)) { // Test the sanity of the input arg
            auto network = Network::instanceNew(name);
            auto notifiee = NetworkTracker::instanceNew();
            notifiee->notifierIs(network);
            networkMap_.insert(NetworkMap::value_type(name, network));
            networkTrackerMap_.insert(NetworkTrackerMap::value_type(name, notifiee));
            return network;
        } 
        
        return null;
    }

    // Executes a personalNew command
    Ptr<Device> personalNew(const string& networkName, const string& deviceName) { 
        if (verifyDeviceNewParameters(networkName, deviceName)) { // Test the sanity of the input args
            auto device = PersonalDevice::instanceNew(deviceName);
            auto n = network(networkName);
            n->deviceIs(device);
            return device;
        }

        return null;
    }

    // Executes a firewallNew command
    Ptr<Device> firewallNew(const string& networkName, const string& deviceName) { 
        if (verifyDeviceNewParameters(networkName, deviceName)) { // Test the sanity of the input args
            auto device = FirewallDevice::instanceNew(deviceName);
            auto n = network(networkName);
            n->deviceIs(device);
            return device;
        }

        return null;
    }

    /* 
        Executes a connectionIs command.
        Return value indicates whether the command was run successfully or not.
    */
    bool connectionIs(const string& networkName, 
                      const string& device1Name, 
                      const U32 p1, 
                      const string& device2Name, 
                      const U32 p2) { 
        if (verifyConnectionIsParameters(networkName, device1Name, p1, device2Name, p2)) { // Test the sanity of the input args
            auto n = network(networkName);
            auto device1 = n->device(device1Name);
            auto device2 = n->device(device2Name);
            device1->connectionIs(p1, device2, p2);
            return true;
        }

        return false;
    }

    /*
        Executes an infectionIs command
        Return value indicates whether the command was run successfully or not.
    */
    bool infectionIs(const string& networkName,
                     const MalwareStrength& infectionStrength,
                     const string& deviceName,
                     const vector<U32> ports) {
        if (!networkExists(networkName)) {
            return false;
        }

        auto n = network(networkName); 
        AttackTarget originOfAttack = computeOriginOfAttack(n->device(deviceName), ports);
        if (originOfAttack.device == null) {
            logError(WARNING, "Could not determine the device and port to start the attack from. Skipping command.");
            return false;
        }

        auto stats = spreadInfection(originOfAttack, infectionStrength);
        auto tracker = networkTracker(networkName);
        printStatisticsForInfectionIsCmd(stats, tracker);
        return true;
    }

    /*
        Helper function used by the infectionIs method.
        Given a device and a list of ports, it traverses the chain of ports to 
        find the device and port from where the infection should start attacking.
        Returns 'null' as the target device if an error is encountered.
    */ 
    AttackTarget computeOriginOfAttack(const Ptr<Device> device, const vector<U32> ports) {
        Ptr<Device> startDevice;
        if (ports.size() == 1) {
            return {device, ports.front(), 1};
        } else {
            startDevice = device;
            for (auto i = 0u; i < ports.size() - 1; i++) {
                auto p = ports[i];
                if (connectedPort(startDevice, p)) { // The port is in use.
                    auto port = startDevice->port(p);
                    startDevice = port.otherDevice();
                } else {
                    logError(WARNING, "The given sequence of ports do not form a connected sequence. Skipping command.");
                    return {null, 0, 0};
                }
            }
        }

        auto startPort = ports.back();
        return {startDevice, startPort, 1};
    }

    /* 
        Start an attack at the specified 'originOfAttack'(ie, device,port).
        Return a collection of stats corresponding to the attack (eg: 'attacked', 'longestPath', etc.)
    */
    InfectionStats spreadInfection(const AttackTarget originOfAttack,
                                   const MalwareStrength& infectionStrength) {        
        InfectionStats stats;
        queue<AttackTarget> targetsToAttack; // List of targets yet to attack
        targetsToAttack.push(originOfAttack);

        while (!targetsToAttack.empty()) {
            auto attackTarget = targetsToAttack.front(); // The (device,port) pair to attack next.
            targetsToAttack.pop();
            auto device = attackTarget.device;
            if (!isInfected(device)) { // Do not revisit an already-infected device
                auto port = attackTarget.port;
                auto numHopsFromOriginOfAttack = attackTarget.numHopsFromOriginOfAttack;
                auto attackSuccessful = tryInfectDevice(device, port, infectionStrength, numHopsFromOriginOfAttack, &targetsToAttack);
                if ((attackSuccessful) && (numHopsFromOriginOfAttack > stats.longestPath)) {
                    stats.longestPath = numHopsFromOriginOfAttack;
                }

                stats.attacked++;
                stats.relativeStrength += infectionStrength - device->port(port).rating().value();
            }
        }

        return stats;
    }

    /*
        Attack the given (device,port) with an infection of the specified strength
        Return value indicates whether the device was infected or not

        Note that the method modifies the input parameter 'targetsToAttack'.
        If a device is infected, its neighbors are added to this queue.
        This is part of the BFS approach of selecting devices to attack.
    */
    bool tryInfectDevice(const Ptr<Device>& device,
                      const U32 portId, 
                      const MalwareStrength& infectionStrength,
                      const U32 numHopsFromOriginOfAttack,
                      queue<AttackTarget>* targetsToAttack) {
        auto port = device->port(portId);
        if (port.rating() >= infectionStrength) { // The infection fails immediately
            return false; 
        }

        device->healthIs("infected");
        for (U32 i = 0; i < device->portCount(); i++) {
            if (connectedPort(device, i)) { // Port is in use
                auto port = device->port(i);
                auto otherDevice = port.otherDevice();
                if (!isInfected(otherDevice)) {
                    AttackTarget p = {port.otherDevice(), port.otherPort(), numHopsFromOriginOfAttack + 1};
                    targetsToAttack->push(p);
                }
            }
        }

        return true;
    }

    /* 
        Executes an infectedDel command.
        Return value indicates whether the command was run successfully or not.
    */
    bool infectedDel(const string& networkName) {
        if (networkExists(networkName)) {
            auto n = network(networkName); // TODO: Rename this variable
            vector<Ptr<Device>> devicesToDelete;

            for (auto it = n->deviceIter(); it != n->deviceIterEnd(); it++) {
                auto device = it->second;
                if (isInfected(device)) {
                    devicesToDelete.push_back(device);
                }
            }

            for (auto it = devicesToDelete.cbegin(); it != devicesToDelete.cend(); it++) {
                auto device = *it;
                disconnectAllPorts(device);
                n->deviceDel(device->name());
            }

            return true;
        }

        return false;
    }

    /* 
        Executes a clone command.
        If successful, returns the cloned device.
        Else, returns null
    */
    Ptr<Device> clone(const string& networkName,
               const string& device1Name,
               const U32 device1Port,
               const string& device2Name,
               const U32 device2Port) {
        if (verifyCloneParameters(networkName, device1Name, device1Port, device2Name, device2Port)) {
            auto n = this->network(networkName); // TODO: Rename this variable
            auto device1 = n->device(device1Name);
            Ptr<Device> device2;

            if (isPersonalDevice(device1)) {
                device2 = PersonalDevice::instanceNew(device2Name);
            } else if (isFirewallDevice(device1)) {
                device2 = FirewallDevice::instanceNew(device2Name);
            } else {
            	logError(WARNING, "Unexpected type of device. Skipping command.");
            	return null;
            }

            n->deviceIs(device2);
            device2->healthIs(device1->health());
            cloneAllPortRatings(device1, device2);
            device1->connectionIs(device1Port, device2, device2Port);

            return device2;
        } 
         
        return null;
    }

    /* 
        Executes a cloneAll command.
        Return value indicates whether the command was run successfully or not.
    */
    bool cloneAll(const string& networkName,
                  const U32 p1,
                  const U32 p2) {
        if (!networkExists(networkName)) {
            return false;
        }

        // If a device is cloned successfully, this would map the device's name to its clone device.
        unordered_map< string, Ptr<Device> > parentNameToClone; 
        std::list< string > parentDeviceNames; // List of names of all the devices in the network.
        auto n = network(networkName);

        for (auto it = n->deviceIter(); it != n->deviceIterEnd(); it++) {
            parentDeviceNames.push_back(it->first);
        }        

        // Clone devices, where possible
        for (auto it = parentDeviceNames.cbegin(); it != parentDeviceNames.cend(); it++) {
            const auto parentName = *it;
            auto cloneName = parentName + "-" + to_string(p1);
            if (!deviceExists(n, cloneName)) { // Check if there's already a device with the same name as cloneName
                auto clonedDevice = clone(networkName, parentName, p1, cloneName, p2);
                if (clonedDevice != null) { // Cloning was successful
                    parentNameToClone[parentName] = clonedDevice;
                }
            }
        }

        // Make connections among clones, where possible.
        // Note that the connections from clones to parents would have already been created by the 'clone' method above.
        for (auto it = parentNameToClone.cbegin(); it != parentNameToClone.cend(); it++) {
            auto parent = n->device(it->first);
            auto clonedDevice = it->second;

            // Traverse through all the ports of the parent device
            for (auto p3 = 0u; p3 < parent->portCount(); p3++) { 
                // Port 'p1' of the parent is connected to the clone. This connection should not be replicated among clones.
                if ((p3 != p1) && (!parent->availablePort(p3))) { 
                    auto parentPort = parent->port(p3);

                    auto otherDevice = parentPort.otherDevice();
                    auto tmp = parentNameToClone.find(otherDevice->name());
                    if (tmp != parentNameToClone.end()) { // 'otherDevice' also has a clone
                        auto otherClone = tmp->second;
                        auto p4 = parentPort.otherPort();
                        
                        if (clonedDevice->availablePort(p3) && otherClone->availablePort(p4)) {
                            clonedDevice->connectionIs(p3, otherClone, p4);
                        }
                    }
                }
            }
        }

        return true;       
    }

    /* 
        Executes a ratingIs command.
        Return value indicates whether the command was run successfully or not.
    */
    bool ratingIs(const string& networkName,
                  const string& deviceName,
                  const U32 p,
                  const MalwareStrength& rating) {
        if(verifyRatingIsParameters(networkName, deviceName, p)) {
            auto n = network(networkName);
            auto device = n->device(deviceName);
            device->portRatingIs(p, rating);
            return true;
        }

        return false;
    }

private:
    NetworkMap networkMap_;
    NetworkTrackerMap networkTrackerMap_;

    void printStatisticsForInfectionIsCmd(InfectionStats stats, Ptr<NetworkTracker> tracker) {
        auto space = " ";
        cout << ""    << tracker->infectedDeviceCount()
             << space << stats.attacked
             << space << stats.relativeStrength
             << space << tracker->personalDeviceCount()
             << space << tracker->firewallDeviceCount()
             << space << stats.longestPath
             << endl;
    }

    // ==============================================================
    //  Methods to test the sanity of the args to different commands.
    //  These methods perform all the error-handling.
    //  Each method that executes a simulation command (eg: networkNew)
    //  first checks the sanity of its args by calling one of these
    //  'verify*' methods and then executes the command only if this 
    //  returns true
    // ==============================================================

    // Test the sanity of the args of a networkNew command
    bool verifyNetworkNewParameters(const string& networkName) {
        if (networkName == "networkNew") {
            logError(WARNING, "Network cannot be named 'networkNew'.");
            return false;
        }

        if (networkMap_.find(networkName) != networkMap_.end()) {
            logError(WARNING, "A network with the same name '" + networkName + "' already exists.");
            return false;
        }

        if ( (networkName.find("'") != string::npos) || (networkName.find("\"") != string::npos) ) {
            logError(WARNING, "Network name cannot contain quotes.");
            return false;
        }

        return true;
    }

    // Test the sanity of the args of either a personalNew or firewallNew command
    bool verifyDeviceNewParameters(const string& networkName, const string& deviceName) {
        if (!networkExists(networkName)) {
            return false;
        }

        if ((deviceName == "personalNew") || (deviceName == "firewallNew")) {
            logError(WARNING, "Devices cannot be named either 'personalNew' or 'firewallNew'.");
            return false;
        }

        if ( (deviceName.find("'") != string::npos) || (deviceName.find("\"") != string::npos) ) {
            logError(WARNING, "Device name cannot contain quotes.");
            return false;
        }

        auto n = network(networkName);
        auto device = n->device(deviceName);
        if (device != null) {
            logError(WARNING, "Device with name '" + deviceName + "' already exists in network '" +networkName + "'.");
            return false;
        }

        return true;
    }

    // Test the sanity of the args of a connectionIs command
    bool verifyConnectionIsParameters(const string& networkName, 
                      const string& device1Name, 
                      const U32 p1, 
                      const string& device2Name, 
                      const U32 p2) { 
        if (!( (networkExists(networkName)) && 
               (deviceExists(networkName, device1Name)) && 
               (deviceExists(networkName, device2Name)) )) {
            return false;
        }

        if (device1Name == device2Name) {
            logError(WARNING, "Cannot connect ports of the same device ('" + device1Name + "') to each other.");
            return false;
        }

        auto n = network(networkName);
        auto device1 = n->device(device1Name);
        auto device2 = n->device(device2Name);

        if ( (p1 >= device1->portCount()) || (p2 >= device2->portCount()) ) {
            logError(WARNING, "Either one or both of the ports exceed the number of ports that the corresponding device has.");
            return false;
        }

        if (!( (device1->availablePort(p1)) && (device2->availablePort(p2)) )) {
            logError(WARNING, "Either sourcePort ('" + device1Name + "," + to_string(p1) 
                     + "') or destinationPort ('" + device2Name + "," + to_string(p2)
                     + "') (or both) are already in use.");
            return false;
        }

        return true;
    }

    // Test the sanity of the args of a clone command
    bool verifyCloneParameters(const string& networkName, 
                               const string device1Name, 
                               const U32 p1, 
                               const string device2Name, 
                               const U32 p2) {
        if (!( (networkExists(networkName)) && (deviceExists(networkName, device1Name)) )) {
            return false;
        }

        auto n = network(networkName);
        if (n->device(device2Name) != null) {
            logError(WARNING, "A device with the name '" + device2Name + "' already exists in network '" + networkName + "'.");
            return false;
        }

        auto device = network(networkName)->device(device1Name);
        auto portCount = device->portCount();
        if ( (p1 >= portCount) || (p2 >= portCount) ) {
            logError(WARNING, "Not cloning ('" + device1Name + "', " + to_string(p1) + ", "
                              + device2Name + ", " + to_string(p2)
                              + ") Either one or both of the portIds exceed the number of ports that the device has.");
            return false;
        }

        if (!(device->availablePort(p1))) {
            logError(WARNING, "Cannot clone device '" + device1Name + "' on port '" + to_string(p1) + "' since the port is in use.");
            return false;
        }

        return true;
    }

    // Test the sanity of the args of a ratingIs command
    bool verifyRatingIsParameters(const string& networkName, const string deviceName, const U32 p) {
        if (!( (networkExists(networkName)) && (deviceExists(networkName, deviceName)) )) {
            return false;
        }

        auto device = network(networkName)->device(deviceName);
        auto portCount = device->portCount();
        if (p >= portCount) {
            logError(WARNING, "Given device '" + deviceName + "' only has " + to_string(portCount) + 
                     " ports. The specified port (" + to_string(p) + ") exceeds this count.");
            return false;
        }

        return true;
    }

    // Check if a network of this name has been instantiated
    bool networkExists(const string& name) {
        auto n = network(name);
        if (n == null) {
            logError(WARNING, "Network does not exist: " + name);
            return false;
        }

        return true;
    }

    // Check if a device of this name has been instantiated in the given network
    bool deviceExists(const string& networkName, const string deviceName) {
        if (networkExists(networkName)) {
            auto n = network(networkName);
            auto device = n->device(deviceName);
            if (device == null) {
                logError(WARNING, "Device '" + deviceName + "' does not exist in network '" + networkName + "'.");
                return false;
            }

            return true;
        } 

        return false;
    }

    // Check if a device of this name has been instantiated in the given network
    bool deviceExists(const Ptr<Network> network, const string& deviceName) {
        return (network->device(deviceName) != null);
    }

    // ==============================================================
};

#endif