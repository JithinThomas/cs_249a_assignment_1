
#ifndef SYSTEM_H
#define SYSTEM_H

#include "fwk/fwk.h"

#include "MalwareStrength.h"
#include "Port.h"
#include "Device.h"
#include "Network.h"
#include "CommonLib.h"

#include <iostream>
#include <fstream>
#include <sstream>
#include <queue>
#include <unordered_map>
#include <utility>
#include <vector>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ifstream;
using std::ostream;
using std::stringstream;

using std::queue;
using std::unordered_map;
using std::vector;

using std::to_string;

using std::list;
using std::stod;
using std::stoi;
using std::to_string;
using std::tuple;

using fwk::BaseNotifiee;
using fwk::NamedInterface;
using fwk::NotifierLib::post;
using fwk::Ptr;

class NetworkTracker;

class DeviceTracker : public Device::Notifiee {
public:
    static DeviceTracker* instanceNew() {
        return new DeviceTracker();
    }

    void networkTrackerIs(const Ptr<NetworkTracker>& networkTracker);
    virtual void onHealth();

private:
    friend class NetworkTracker;

    Ptr<NetworkTracker> networkTracker_;   
};

class NetworkTracker : public Network::Notifiee {
public:
    NetworkTracker() : 
        personalDeviceCount_(0),
        firewallDeviceCount_(0),
        infectedDeviceCount_(0) {
        // Nothing to do
    }

    static Ptr<NetworkTracker> instanceNew() {
        return new NetworkTracker();
    }

    // TODO: Does this method need to be 'virtual'?
    virtual void onDeviceNew(const Ptr<Device>& device) { 
        addDevice(device);
        changeDeviceCount(device, true);
    }

    // TODO: Does this method need to be 'virtual'?
    virtual void onDeviceDel(const Ptr<Device>&  device) {
        changeDeviceCount(device, false);
        if (isInfected(device)) {
            infectedDeviceCount_--;
        }
    }

    void onDeviceHealth(const Ptr<Device>& device) {
        auto delta = isInfected(device) ? 1 : -1;
        infectedDeviceCount_ += delta;
    }

    unsigned int personalDeviceCount() {
        return personalDeviceCount_;
    }

    unsigned int firewallDeviceCount() {
        return firewallDeviceCount_;
    }

    unsigned int infectedDeviceCount() {
        return infectedDeviceCount_;
    }

private:
    unsigned int personalDeviceCount_;
    unsigned int firewallDeviceCount_;
    unsigned int infectedDeviceCount_;

    // TODO: Rename function and 'inc' parameter? Should we use a boolean param or use an enum {NEW, DEL}
    void changeDeviceCount(const Ptr<Device>&  device, bool inc) {
        auto delta = inc ? 1 : -1;
        if (isPersonalDevice(device)) {
            personalDeviceCount_ += delta;   
        } else if (isFirewallDevice(device)) {
            firewallDeviceCount_ += delta;
        } else {
        	cout << "[WARNING]: changeDeviceCount(): Unexpected type of device" << endl;
        }
    }

    void addDevice(const Ptr<Device>& device) {
        // TODO: When deviceTracker is of type Ptr<DeviceTracker>, the run ends in seg fault. Why? (It works when the type is DeviceTracker* instead)
        //const Ptr<DeviceTracker> deviceTracker = DeviceTracker::instanceNew();
        const auto deviceTracker = DeviceTracker::instanceNew();
        deviceTracker->notifierIs(device);
        deviceTracker->networkTrackerIs(this);
    }
};

void DeviceTracker::networkTrackerIs(const Ptr<NetworkTracker>& networkTracker) {
    networkTracker_ = networkTracker;
}

void DeviceTracker::onHealth() {
    networkTracker_->onDeviceHealth(notifier());
} 

class System : public NamedInterface {
public:
	typedef unordered_map< string, Ptr<Network> > NetworkMap;
    typedef unordered_map< string, Ptr<NetworkTracker> > NetworkTrackerMap;

	static Ptr<System> instanceNew(string name) {
        return new System(name);
    }

    System(const string& name) :
    	NamedInterface(name)
	{
		//Nothing to do
	}

    Ptr<Network> network(const string& name) {
    	auto it = networkMap_.find(name);
    	if (it != networkMap_.end()) {
    		return it->second;	
    	}
        
        return null;
    }

    Ptr<NetworkTracker> networkTracker(const string& name) {
        auto it = networkTrackerMap_.find(name);
        if (it != networkTrackerMap_.end()) {
            return it->second;  
        }
        
        return null;
    }

    // Executes a networkNew command
    Ptr<Network> networkNew(const string& name) { 
        if (verifyNetworkNewParameters(name)) {
            auto network = Network::instanceNew(name);
            auto notifiee = NetworkTracker::instanceNew();
            notifiee->notifierIs(network);
            networkMap_.insert(NetworkMap::value_type(name, network));
            networkTrackerMap_.insert(NetworkTrackerMap::value_type(name, notifiee));
            return network;
        } 
        
        return null;
    }

    // Executes a personalNew command
    Ptr<Device> personalNew(const string& networkName, const string& deviceName) { 
        if (verifyDeviceNewParameters(networkName, deviceName)) {
            auto device = PersonalDevice::instanceNew(deviceName);
            auto n = network(networkName); // TODO: Rename this variable
            n->deviceIs(device);
            return device;
        }

        return null;
    }

    // Executes a firewallNew command
    Ptr<Device> firewallNew(const string& networkName, const string& deviceName) { 
        if (verifyDeviceNewParameters(networkName, deviceName)) {
            auto device = FirewallDevice::instanceNew(deviceName);
            auto n = network(networkName);
            n->deviceIs(device); // TODO: Rename this variable
            return device;
        }

        return null;
    }

    bool connectionIs(const string& networkName, 
                      const string& device1Name, 
                      const U32 p1, 
                      const string& device2Name, 
                      const U32 p2) { 
        if (verifyConnectionIsParameters(networkName, device1Name, p1, device2Name, p2)) {
            auto n = network(networkName); // TODO: Rename this variable
            auto device1 = n->device(device1Name); // TODO: Check if returned device is null, ie, such a device has not been instantiated
            auto device2 = n->device(device2Name);
            device1->connectionIs(p1, device2, p2);
            return true;
        }

        return false;
    }

    bool infectionIs(const string& networkName,
                     const MalwareStrength& infectionStrength,
                     const string& deviceName,
                     const vector<U32> ports) {
        if (!networkExists(networkName)) {
            return false;
        }

        auto n = network(networkName); // TODO: Rename this variable
        AttackTarget originOfAttack = computeOriginOfAttack(n->device(deviceName), ports);
        if (originOfAttack.device == null) {
            logError(WARNING, "Could not determine the device and port to start the attack from. Skipping command.");
            return false;
        }

        auto stats = spreadInfection(originOfAttack, infectionStrength);
        auto tracker = networkTracker(networkName);
        printStatisticsForInfectionIsCmd(stats, tracker);
        return true;
    }

    AttackTarget computeOriginOfAttack(const Ptr<Device> device, const vector<U32> ports) {
        Ptr<Device> startDevice;
        if (ports.size() == 1) {
            return {device, ports.front(), 1};
        } else {
            startDevice = device;
            for (auto i = 0u; i < ports.size() - 1; i++) {
                auto p = ports[i];
                if (connectedPort(startDevice, p)) {
                    auto port = startDevice->port(p);
                    startDevice = port.otherDevice();
                } else {
                    logError(WARNING, "The given sequence of ports do not form a connected sequence. Skipping command.");
                    return {null, 0, 0};
                }
            }
        }

        auto startPort = ports.back();
        return {startDevice, startPort, 1};
    }

    InfectionStats spreadInfection(const AttackTarget originOfAttack,
                                   const MalwareStrength& infectionStrength) {        
        InfectionStats stats;
        queue<AttackTarget> targetsToAttack;
        targetsToAttack.push(originOfAttack);

        while (!targetsToAttack.empty()) {
            auto attackTarget = targetsToAttack.front();
            targetsToAttack.pop();
            auto device = attackTarget.device;
            if (!isInfected(device)) {
                auto port = attackTarget.port;
                auto numHopsFromOriginOfAttack = attackTarget.numHopsFromOriginOfAttack;
                auto attackSuccessful = tryInfectDevice(device, port, infectionStrength, numHopsFromOriginOfAttack, &targetsToAttack);
                if ((attackSuccessful) && (numHopsFromOriginOfAttack > stats.longestPath)) {
                    stats.longestPath = numHopsFromOriginOfAttack;
                }

                stats.attacked++;
                stats.relativeStrength += infectionStrength - device->port(port).rating().value();
            }
        }

        return stats;
    }

    bool tryInfectDevice(const Ptr<Device>& device,
                      const U32 portId, 
                      const MalwareStrength& infectionStrength,
                      const U32 numHopsFromOriginOfAttack,
                      queue<AttackTarget>* targetsToAttack) {
        auto port = device->port(portId);
        if (port.rating() >= infectionStrength) { // The infection fails immediately
            return false; 
        }

        device->healthIs("infected");
        for (U32 i = 0; i < device->portCount(); i++) {
            if (connectedPort(device, i)) {
                auto port = device->port(i);
                auto otherDevice = port.otherDevice();
                if (!isInfected(otherDevice)) {
                    AttackTarget p = {port.otherDevice(), port.otherPort(), numHopsFromOriginOfAttack + 1};
                    targetsToAttack->push(p);
                }
            }
        }

        return true;
    }

    bool infectedDel(const string& networkName) {
        if (networkExists(networkName)) {
            auto n = network(networkName); // TODO: Rename this variable
            vector<Ptr<Device>> devicesToDelete;

            for (auto it = n->deviceIter(); it != n->deviceIterEnd(); it++) {
                auto device = it->second;
                if (isInfected(device)) {
                    devicesToDelete.push_back(device);
                }
            }

            for (auto it = devicesToDelete.cbegin(); it != devicesToDelete.cend(); it++) {
                auto device = *it;
                disconnectAllPorts(device);
                n->deviceDel(device->name());
            }

            return true;
        }

        return false;
    }

    Ptr<Device> clone(const string& networkName,
               const string& device1Name,
               const U32 device1Port,
               const string& device2Name,
               const U32 device2Port) {
        if (verifyCloneParameters(networkName, device1Name, device1Port, device2Name, device2Port)) {
            auto n = this->network(networkName); // TODO: Rename this variable
            auto device1 = n->device(device1Name);
            Ptr<Device> device2;

            if (isPersonalDevice(device1)) {
                device2 = PersonalDevice::instanceNew(device2Name);
            } else if (isFirewallDevice(device1)) {
                device2 = FirewallDevice::instanceNew(device2Name);
            } else {
            	logError(WARNING, "Unexpected type of device. Skipping command.");
            	return null;
            }

            n->deviceIs(device2);
            device2->healthIs(device1->health());
            cloneAllPortRatings(device1, device2);
            device1->connectionIs(device1Port, device2, device2Port);

            return device2;
        } 
         
        return null;
    }

    // TODO: Refactor this function
    bool cloneAll(const string& networkName,
                  const U32 p1,
                  const U32 p2) {
        if (!networkExists(networkName)) {
            return false;
        }

        auto n = network(networkName);
        unordered_map< string, Ptr<Device> > parentNameToClone;
        std::list< string > parentDeviceNames;

        for (auto it = n->deviceIter(); it != n->deviceIterEnd(); it++) {
            parentDeviceNames.push_back(it->first);
        }        

        // Clone devices, where possible
        for (auto it = parentDeviceNames.cbegin(); it != parentDeviceNames.cend(); it++) {
            const auto parentName = *it;
            auto cloneName = parentName + "-" + to_string(p1);
            if (!deviceExists(n, cloneName)) {
                auto clonedDevice = clone(networkName, parentName, p1, cloneName, p2);
                if (clonedDevice != null) { // Cloning was successful
                    parentNameToClone[parentName] = clonedDevice;
                } else {
                    // TOOD: Print warning
                }
            } else {
                // TOOD: Print warning that a device of that name already exists. Hence, not cloning parent.
            }
        }

        // Connect clones to parents and then make connections among clones
        for (auto it = parentNameToClone.cbegin(); it != parentNameToClone.cend(); it++) {
            auto parent = n->device(it->first);
            auto clonedDevice = it->second;

            for (auto p3 = 0u; p3 < parent->portCount(); p3++) {
                if ((p3 != p1) && (!parent->availablePort(p3))) { // Port 'p1' of the parent is already in use. Its been connected to the clone
                    auto parentPort = parent->port(p3);

                    auto otherDevice = parentPort.otherDevice();
                    auto tmp = parentNameToClone.find(otherDevice->name());
                    if (tmp != parentNameToClone.end()) {
                        auto otherClone = tmp->second;
                        auto p4 = parentPort.otherPort();
                        
                        if (clonedDevice->availablePort(p3) && otherClone->availablePort(p4)) {
                            clonedDevice->connectionIs(p3, otherClone, p4);
                        } else {
                            // TODO: Print warning and skip this connection
                        }
                    }
                }
            }
        }

        return true;       
    }

    bool ratingIs(const string& networkName,
                  const string& deviceName,
                  const U32 p,
                  const MalwareStrength& rating) {
        if(verifyRatingIsParameters(networkName, deviceName, p)) {
            auto n = network(networkName);
            auto device = n->device(deviceName);
            device->portRatingIs(p, rating);
            return true;
        }

        return false;
    }

private:
    NetworkMap networkMap_;
    NetworkTrackerMap networkTrackerMap_;

    void printStatisticsForInfectionIsCmd(InfectionStats stats, Ptr<NetworkTracker> tracker) {
        auto space = " ";
        cout << ""    << tracker->infectedDeviceCount()
             << space << stats.attacked
             << space << stats.relativeStrength
             << space << tracker->personalDeviceCount()
             << space << tracker->firewallDeviceCount()
             << space << stats.longestPath
             << endl;
    }

    // ==============================================================
    //  Methods to test the sanity of the args to different commands
    // ==============================================================

    bool verifyNetworkNewParameters(const string& networkName) {
        if (networkName == "networkNew") {
            logError(WARNING, "Network cannot be named 'networkNew'.");
            return false;
        }

        if (networkMap_.find(networkName) != networkMap_.end()) {
            logError(WARNING, "A network with the same name '" + networkName + "' already exists.");
            return false;
        }

        if ( (networkName.find("'") != string::npos) || (networkName.find("\"") != string::npos) ) {
            logError(WARNING, "Network name cannot contain quotes.");
            return false;
        }

        return true;
    }

    bool verifyDeviceNewParameters(const string& networkName, const string& deviceName) {
        if (!networkExists(networkName)) {
            return false;
        }

        if ((deviceName == "personalNew") || (deviceName == "firewallNew")) {
            logError(WARNING, "Devices cannot be named either 'personalNew' or 'firewallNew'.");
            return false;
        }

        if ( (deviceName.find("'") != string::npos) || (deviceName.find("\"") != string::npos) ) {
            logError(WARNING, "Device name cannot contain quotes.");
            return false;
        }

        auto n = network(networkName);
        auto device = n->device(deviceName);
        if (device != null) {
            logError(WARNING, "Device with name '" + deviceName + "' already exists in network '" +networkName + "'.");
            return false;
        }

        return true;
    }

    bool verifyConnectionIsParameters(const string& networkName, 
                      const string& device1Name, 
                      const U32 p1, 
                      const string& device2Name, 
                      const U32 p2) { 
        if (!( (networkExists(networkName)) && (deviceExists(networkName, device1Name)) && (deviceExists(networkName, device2Name)) )) {
            return false;
        }

        if (device1Name == device2Name) {
            logError(WARNING, "Cannot connect ports of the same device ('" + device1Name + "') to each other.");
            return false;
        }

        auto n = network(networkName);
        auto device1 = n->device(device1Name);
        auto device2 = n->device(device2Name);

        if ( (p1 >= device1->portCount()) || (p2 >= device2->portCount()) ) {
            logError(WARNING, "Either one or both of the ports exceed the number of ports that the corresponding device has.");
            return false;
        }

        if (!( (device1->availablePort(p1)) && (device2->availablePort(p2)) )) {
            logError(WARNING, "Either sourcePort ('" + device1Name + "," + to_string(p1) 
                     + "') or destinationPort ('" + device2Name + "," + to_string(p2)
                     + "') (or both) are already in use.");
            return false;
        }

        return true;
    }

    bool verifyCloneParameters(const string& networkName, 
                               const string device1Name, 
                               const U32 p1, 
                               const string device2Name, 
                               const U32 p2) {
        if (!( (networkExists(networkName)) && (deviceExists(networkName, device1Name)) )) {
            return false;
        }

        auto n = network(networkName);
        if (n->device(device2Name) != null) {
            logError(WARNING, "A device with the name '" + device2Name + "' already exists in network '" + networkName + "'.");
            return false;
        }

        auto device = network(networkName)->device(device1Name);
        auto portCount = device->portCount();
        if ( (p1 >= portCount) || (p2 >= portCount) ) {
            logError(WARNING, "Not cloning ('" + device1Name + "', " + to_string(p1) + ", "
                              + device2Name + ", " + to_string(p2)
                              + ") Either one or both of the portIds exceed the number of ports that the device has.");
            return false;
        }

        if (!(device->availablePort(p1))) {
            logError(WARNING, "Cannot clone device '" + device1Name + "' on port '" + to_string(p1) + "' since the port is in use.");
            return false;
        }

        return true;
    }

    bool verifyRatingIsParameters(const string& networkName, const string deviceName, const U32 p) {
        if (!( (networkExists(networkName)) && (deviceExists(networkName, deviceName)) )) {
            return false;
        }

        auto device = network(networkName)->device(deviceName);
        auto portCount = device->portCount();
        if (p >= portCount) {
            logError(WARNING, "Given device '" + deviceName + "' only has " + to_string(portCount) + 
                     " ports. The specified port (" + to_string(p) + ") exceeds this count.");
            return false;
        }

        return true;
    }

    bool networkExists(const string& name) {
        auto n = network(name);
        if (n == null) {
            logError(WARNING, "Network does not exist: " + name);
            return false;
        }

        return true;
    }

    bool deviceExists(const string& networkName, const string deviceName) {
        if (networkExists(networkName)) {
            auto n = network(networkName);
            auto device = n->device(deviceName);
            if (device == null) {
                logError(WARNING, "Device '" + deviceName + "' does not exist in network '" + networkName + "'.");
                return false;
            }

            return true;
        } 

        return false;
    }

    bool deviceExists(const Ptr<Network> network, const string& deviceName) {
        return (network->device(deviceName));
    }

    // ==============================================================
};

#endif