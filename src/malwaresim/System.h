
#ifndef SYSTEM_H
#define SYSTEM_H

#include "fwk/fwk.h"

#include "MalwareStrength.h"
#include "Port.h"
#include "Device.h"
#include "Network.h"
#include "CommonLib.h"

#include <iostream>
#include <fstream>
#include <sstream>
#include <queue>
#include <regex>
#include <set>
#include <tuple>
#include <unordered_map>
#include <utility>
#include <vector>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ifstream;
using std::ostream;
using std::stringstream;

using std::queue;
using std::unordered_map;
using std::vector;

using std::to_string;

using std::list;
using std::make_pair;
using std::make_tuple;
using std::pair;
using std::regex;
using std::regex_match;
using std::set;
using std::smatch;
using std::stod;
using std::stoi;
using std::to_string;
using std::tuple;

using fwk::BaseNotifiee;
using fwk::NamedInterface;
using fwk::NotifierLib::post;
using fwk::Ptr;

class NetworkTracker;

class DeviceTracker : public Device::Notifiee {
public:
    static DeviceTracker* instanceNew() {
        return new DeviceTracker();
    }

    void networkTrackerIs(const Ptr<NetworkTracker>& networkTracker);
    virtual void onHealth();

private:
    friend class NetworkTracker;

    Ptr<NetworkTracker> networkTracker_;   
};

class NetworkTracker : public Network::Notifiee {
public:
    NetworkTracker() : 
        personalDeviceCount_(0),
        firewallDeviceCount_(0),
        infectedDeviceCount_(0) {
        // Nothing to do
    }

    static Ptr<NetworkTracker> instanceNew() {
        return new NetworkTracker();
    }

    // TODO: Does this method need to be 'virtual'?
    virtual void onDeviceNew(const Ptr<Device>& device) { 
        addDevice(device);
        changeDeviceCount(device, true);
    }

    // TODO: Does this method need to be 'virtual'?
    virtual void onDeviceDel(const Ptr<Device>&  device) {
        changeDeviceCount(device, false);
        if (isInfected(device)) {
            infectedDeviceCount_--;
        }
    }

    void onDeviceHealth(const Ptr<Device>& device) {
        auto delta = isInfected(device) ? 1 : -1;
        infectedDeviceCount_ += delta;
    }

    unsigned int personalDeviceCount() {
        return personalDeviceCount_;
    }

    unsigned int firewallDeviceCount() {
        return firewallDeviceCount_;
    }

    unsigned int infectedDeviceCount() {
        return infectedDeviceCount_;
    }

private:
    unsigned int personalDeviceCount_;
    unsigned int firewallDeviceCount_;
    unsigned int infectedDeviceCount_;

    // TODO: Rename function and 'inc' parameter? Should we use a boolean param or use an enum {NEW, DEL}
    void changeDeviceCount(const Ptr<Device>&  device, bool inc) {
        auto delta = inc ? 1 : -1;
        if (isPersonalDevice(device)) {
            personalDeviceCount_ += delta;   
        } else if (isFirewallDevice(device)) {
            firewallDeviceCount_ += delta;
        } else {
        	cout << "[WARNING]: changeDeviceCount(): Unexpected type of device" << endl;
        }
    }

    void addDevice(const Ptr<Device>& device) {
        // TODO: When deviceTracker is of type Ptr<DeviceTracker>, the run ends in seg fault. Why? (It works when the type is DeviceTracker* instead)
        //const Ptr<DeviceTracker> deviceTracker = DeviceTracker::instanceNew();
        const auto deviceTracker = DeviceTracker::instanceNew();
        deviceTracker->notifierIs(device);
        deviceTracker->networkTrackerIs(this);
    }
};

void DeviceTracker::networkTrackerIs(const Ptr<NetworkTracker>& networkTracker) {
    networkTracker_ = networkTracker;
}

void DeviceTracker::onHealth() {
    networkTracker_->onDeviceHealth(notifier());
} 

//TODO:
// (i) The warning messages should be sent to stderr not stdout

class System : public NamedInterface {
public:
	typedef unordered_map< string, Ptr<Network> > NetworkMap;
    typedef unordered_map< string, Ptr<NetworkTracker> > NetworkTrackerMap;
    typedef tuple< Ptr<Device>, U32, U32 > AttackTarget;

	static Ptr<System> instanceNew(string name) {
        return new System(name);
    }

    System(const string& name) :
    	NamedInterface(name)
	{
		//Nothing to do
	}

    // TODO: Throw an exception or warning if a network with the given name has not been instantiated
    Ptr<Network> network(const string& name) {
    	auto it = networkMap_.find(name);
    	if (it != networkMap_.end()) {
    		return it->second;	
    	}
        
        return null;
    }

    Ptr<NetworkTracker> networkTracker(const string& name) {
        auto it = networkTrackerMap_.find(name);
        if (it != networkTrackerMap_.end()) {
            return it->second;  
        }
        
        return null;
    }

    // Executes a networkNew command
    Ptr<Network> networkNew(const string& name) { 
        if (verifyNetworkNewParameters(name)) {
            auto network = Network::instanceNew(name);
            auto notifiee = NetworkTracker::instanceNew();
            notifiee->notifierIs(network);
            networkMap_.insert(NetworkMap::value_type(name, network));
            networkTrackerMap_.insert(NetworkTrackerMap::value_type(name, notifiee));
            return network;
        } 
        
        return null;
    }

    // Executes a personalNew command
    Ptr<Device> personalNew(const string& networkName, const string& deviceName) { 
        if (verifyDeviceNewParameters(networkName, deviceName)) {
            auto device = PersonalDevice::instanceNew(deviceName);
            auto n = network(networkName); // TODO: Rename this variable
            n->deviceIs(device);
            return device;
        }

        return null;
    }

    // Executes a firewallNew command
    Ptr<Device> firewallNew(const string& networkName, const string& deviceName) { 
        if (verifyDeviceNewParameters(networkName, deviceName)) {
            auto device = FirewallDevice::instanceNew(deviceName);
            auto n = network(networkName);
            n->deviceIs(device); // TODO: Rename this variable
            return device;
        }

        return null;
    }

    bool connectionIs(const string& networkName, 
                      const string& device1Name, 
                      const U32 p1, 
                      const string& device2Name, 
                      const U32 p2) { 
        if (verifyConnectionIsParameters(networkName, device1Name, p1, device2Name, p2)) {
            auto n = network(networkName); // TODO: Rename this variable
            auto device1 = n->device(device1Name); // TODO: Check if returned device is null, ie, such a device has not been instantiated
            auto device2 = n->device(device2Name);
            device1->connectionIs(p1, device2, p2);
            return true;
        }

        return false;
    }

    AttackTarget computeOriginOfAttack(const Ptr<Device> device, const vector<U32> ports) {
        Ptr<Device> startDevice;
        if (ports.size() == 1) {
            return make_tuple(device, ports.front(), 1);
        } else {
            startDevice = device;
            for (auto i = 0u; i < ports.size() - 1; i++) {
                auto p = ports[i];
                if (connectedPort(startDevice, p)) {
                    auto port = startDevice->port(p);
                    startDevice = port.otherDevice();
                } else {
                	cout << "[WARNING]: infectionIs(): The given sequence of ports do not form a connected sequence. Skipping command." << endl;
                	return make_tuple(null, 0, 0);
                }
            }
        }

        auto startPort = ports.back();
        return make_tuple(startDevice, startPort, 1);
    }

    // TODO: Refactor the code in this function and the 'infectDevice' method
    // Could abstract AttackTarget as a class
    bool infectionIs(const string& networkName,
                     const MalwareStrength& infectionStrength,
                     const string& deviceName,
                     const vector<U32> ports) {
        if (networkExists(networkName)) {
            auto n = network(networkName); // TODO: Rename this variable
            AttackTarget originOfAttack = computeOriginOfAttack(n->device(deviceName), ports);
            if (std::get<0>(originOfAttack) == null) {
                logError(WARNING, "Could not determine the device and port to start the attack from. Skipping command.");
            	return false;
            }
            
            queue<AttackTarget> targetsToAttack;
            set<string> devicesAttacked;
            auto longestPath = 0u;
            auto relativeStrength = 0.0;
            targetsToAttack.push(originOfAttack);

            while (!targetsToAttack.empty()) {
                auto attackTarget = targetsToAttack.front();
                targetsToAttack.pop();
                auto device = std::get<0>(attackTarget);
                if (!isInfected(device)) {
                    auto port = std::get<1>(attackTarget);
                    auto numHopsFromOriginOfAttack = std::get<2>(attackTarget);
                    auto attackSuccessful = infectDevice(device, port, infectionStrength, numHopsFromOriginOfAttack, &targetsToAttack);
                    if ((attackSuccessful) && (numHopsFromOriginOfAttack > longestPath)) {
                        longestPath = numHopsFromOriginOfAttack;
                    }

                    devicesAttacked.insert(device->name());
                    relativeStrength += infectionStrength - device->port(port).rating();
                }
            }

            auto tracker = networkTracker(networkName);
            printStatisticsForInfectionIsCmd(tracker, devicesAttacked.size(), relativeStrength, longestPath);
            return true;
        }

        return false;
    }

    bool infectDevice(const Ptr<Device>& device,
                      const U32 portId, 
                      const MalwareStrength& infectionStrength,
                      const U32 numHopsFromOriginOfAttack,
                      queue<AttackTarget>* targetsToAttack) {
        auto port = device->port(portId);
        if (port.rating() >= infectionStrength) { // The infection fails immediately
            return false; 
        }

        device->healthIs("infected");
        for (U32 i = 0; i < device->portCount(); i++) {
            if (connectedPort(device, i)) {
                auto port = device->port(i);
                auto otherDevice = port.otherDevice();
                if (!isInfected(otherDevice)) {
                    AttackTarget p = make_tuple(port.otherDevice(), port.otherPort(), numHopsFromOriginOfAttack + 1);
                    targetsToAttack->push(p);
                }
            }
        }

        return true;
    }

    bool infectedDel(const string& networkName) {
        if (networkExists(networkName)) {
            auto n = network(networkName); // TODO: Rename this variable
            vector<Ptr<Device>> devicesToDelete;

            for (auto it = n->deviceIter(); it != n->deviceIterEnd(); it++) {
                auto device = it->second;
                if (isInfected(device)) {
                    devicesToDelete.push_back(device);
                }
            }

            for (auto it = devicesToDelete.cbegin(); it != devicesToDelete.cend(); it++) {
                auto device = *it;
                disconnectAllPorts(device);
                n->deviceDel(device->name());
            }

            return true;
        }

        return false;
    }

    Ptr<Device> clone(const string& networkName,
               const string& device1Name,
               const U32 device1Port,
               const string& device2Name,
               const U32 device2Port) {
        if (verifyCloneParameters(networkName, device1Name, device1Port)) {
            auto n = this->network(networkName); // TODO: Rename this variable
            auto device1 = n->device(device1Name);
            Ptr<Device> device2;

            if (isPersonalDevice(device1)) {
                device2 = PersonalDevice::instanceNew(device2Name);
            } else if (isFirewallDevice(device1)) {
                device2 = FirewallDevice::instanceNew(device2Name);
            } else {
            	logError(WARNING, "Unexpected type of device. Skipping command.");
            	return null;
            }

            n->deviceIs(device2);
            device2->healthIs(device1->health());
            cloneAllPortRatings(device1, device2);
            device1->connectionIs(device1Port, device2, device2Port);

            return device2;
        } 
         
        return null;
    }

    // TODO: Refactor this function
    bool cloneAll(const string& networkName,
                  const U32 p1,
                  const U32 p2) {
        if (!networkExists(networkName)) {
            return false;
        }

        auto n = network(networkName);
        unordered_map< string, Ptr<Device> > parentNameToClone;
        std::list< string > parentDeviceNames;

        for (auto it = n->deviceIter(); it != n->deviceIterEnd(); it++) {
            parentDeviceNames.push_back(it->first);
        }        

        for (auto it = parentDeviceNames.cbegin(); it != parentDeviceNames.cend(); it++) {
            const auto parentName = *it;
            auto cloneName = parentName + "-" + to_string(p1);
            if (!deviceExists(n, cloneName)) {
                auto clonedDevice = clone(networkName, parentName, p1, cloneName, p2);
                if (clonedDevice) { // Cloning was successful
                    parentNameToClone[parentName] = clonedDevice;
                } else {
                    // TOOD: Print warning
                }
            } else {
                // TOOD: Print warning that a device of that name already exists. Hence, not cloning parent.
            }
        }

        for (auto it = parentNameToClone.cbegin(); it != parentNameToClone.cend(); it++) {
            auto parent = n->device(it->first);
            auto clonedDevice = it->second;

            for (auto p3 = 0u; p3 < parent->portCount(); p3++) {
                if ((p3 != p1) && (!parent->availablePort(p3))) { // Port 'p1' of the parent is already in use. Its been connected to the clone
                    auto parentPort = parent->port(p3);

                    auto otherDevice = parentPort.otherDevice();
                    auto tmp = parentNameToClone.find(otherDevice->name());
                    if (tmp != parentNameToClone.end()) {
                        auto otherClone = tmp->second;
                        auto p4 = parentPort.otherPort();
                        
                        if (clonedDevice->availablePort(p3) && otherClone->availablePort(p4)) {
                            clonedDevice->connectionIs(p3, otherClone, p4);
                        } else {
                            // TODO: Print warning and skip this connection
                        }
                    }
                }
            }
        }

        return true;       
    }

    bool ratingIs(const string& networkName,
                  const string& deviceName,
                  const U32 p,
                  const MalwareStrength& rating) {
        if (networkExists(networkName) && deviceExists(networkName, deviceName)) {
            auto n = network(networkName);
            auto device = n->device(deviceName);
            device->portRatingIs(p, rating);
            return true;
        }

        return false;
    }

private:
    NetworkMap networkMap_;
    NetworkTrackerMap networkTrackerMap_;

    void printStatisticsForInfectionIsCmd(const Ptr<NetworkTracker> networkTracker, 
                                          const int numDevicesAttacked, 
                                          const double relativeStrength, 
                                          const int longestPath) {
        auto space = " ";
        cout << ""    << networkTracker->infectedDeviceCount()
             << space << numDevicesAttacked
             << space << relativeStrength
             << space << networkTracker->personalDeviceCount()
             << space << networkTracker->firewallDeviceCount()
             << space << longestPath
             << endl;
    }

    // ==============================================================
    //  Methods to test the sanity of the args to different commands
    // ==============================================================

    bool verifyNetworkNewParameters(const string& networkName) {
        if (networkName == "networkNew") {
            logError(WARNING, "Network cannot be named 'networkNew'. Skipping command.");
            return false;
        }

        if (networkMap_.find(networkName) != networkMap_.end()) {
            logError(WARNING, "A network with the same name '" + networkName + "' already exists. Skipping command.");
            return false;
        }

        if (networkName.find("'") != string::npos) {
            logError(WARNING, "Network name cannot contain quotes");
            return false;
        }

        return true;
    }

    bool verifyDeviceNewParameters(const string& networkName, const string& deviceName) {
        if (!networkExists(networkName)) {
            return false;
        }

        if ((deviceName == "personalNew") || (deviceName == "firewallNew")) {
            logError(WARNING, "Devices cannot be named either 'personalNew' or 'firewallNew'. Skipping command.");
            return false;
        }

        if (deviceName.find("'") != string::npos) {
            logError(WARNING, "Device name cannot contain quotes");
            return false;
        }

        auto n = network(networkName);
        auto device = n->device(deviceName);
        if (device != null) {
            logError(WARNING, "Device with name '" + deviceName + "' already exists in network '" +networkName + "'. Skipping command.");
            return false;
        }

        return true;
    }

    bool verifyConnectionIsParameters(const string& networkName, 
                      const string& device1Name, 
                      const U32 p1, 
                      const string& device2Name, 
                      const U32 p2) { 
        if (!( (networkExists(networkName)) && (deviceExists(networkName, device1Name)) && (deviceExists(networkName, device2Name)) )) {
            return false;
        }

        if (device1Name == device2Name) {
            logError(WARNING, "Cannot connect ports of the same device ('" + device1Name + "') to each other. Skipping command.");
            return false;
        }

        auto n = network(networkName);
        auto device1 = n->device(device1Name);
        auto device2 = n->device(device2Name);
        if (!( (device1->availablePort(p1)) && (device2->availablePort(p2)) )) {
            logError(WARNING, "Either sourcePort ('" + device1Name + "," + to_string(p1) 
                     + "') or destinationPort ('" + device2Name + "," + to_string(p2)
                     + "') (or both) are already in use. Skipping command.");
        }

        return true;
    }

    bool verifyCloneParameters(const string& networkName, const string deviceName, const U32 p) {
        if (!( (networkExists(networkName)) && (deviceExists(networkName, deviceName)) )) {
            return false;
        }

        auto device = network(networkName)->device(deviceName);
        if (!(device->availablePort(p))) {
            logError(WARNING, "Cannot clone device '" + deviceName + "' on port '" + to_string(p) + "' since the port is in use. Skipping command.");
            return false;
        }

        return true;
    }

    bool networkExists(const string& name) {
        auto n = network(name);
        if (n == null) {
            logError(WARNING, "Network does not exist: " + name);
            return false;
        }

        return true;
    }

    bool deviceExists(const string& networkName, const string deviceName) {
        if (networkExists(networkName)) {
            auto n = network(networkName);
            auto device = n->device(deviceName);
            if (device == null) {
                logError(WARNING, "Device '" + deviceName + "' does not exist in network '" + networkName + "'.");
                return false;
            }

            return true;
        } 

        return false;
    }

    bool deviceExists(const Ptr<Network> network, const string& deviceName) {
        return (network->device(deviceName));
    }

    // ==============================================================
};

#endif