//
// Stub for main program for Malware Simulation problem.
//
// Copy this file to main.cxx and then edit it to implement your solution.
//

#include "fwk/fwk.h"

#include "MalwareStrength.h"
#include "Port.h"
#include "Device.h"
#include "Network.h"
#include "System.h"

#include <iostream>
#include <fstream>
#include <sstream>
#include <queue>
#include <regex>
#include <set>
#include <tuple>
#include <unordered_map>
#include <utility>
#include <vector>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ifstream;
using std::ostream;
using std::stringstream;

using std::queue;
using std::unordered_map;
using std::vector;

using std::to_string;

using std::list;
using std::make_pair;
using std::make_tuple;
using std::pair;
using std::regex;
using std::regex_match;
using std::set;
using std::smatch;
using std::stod;
using std::stoi;
using std::tuple;

using fwk::Ptr;

//
// Class for main simulation logic.
//
class MalwareSim : public fwk::PtrInterface {
public:

    static Ptr<MalwareSim> instanceNew() {
        return new MalwareSim();
    }

    //
    // Read data in, parse it, excute commands.
    //
    void evalStream(istream& input) {
        auto sys = System::instanceNew("system-1");
        string command;
        while(getline(input, command)) {
            auto typeAndArgs = commandTypeAndArgs(command);
            auto commandType = typeAndArgs.first;
            auto commandArgs = typeAndArgs.second;
            bool res = true;

            switch(commandType) {
                case NETWORK_NEW     : res = evalNetworkNewCmd(sys, commandArgs); break;
                case PERSONAL_NEW    : res = evalPersonalNewCmd(sys, commandArgs); break;
                case FIREWALL_NEW    : res = evalFirewallNewCmd(sys, commandArgs); break;
                case CONNECTION_IS   : res = evalConnectionIsCmd(sys, commandArgs); break;
                case INFECTION_IS    : res = evalInfectionIsCmd(sys, commandArgs); break;
                case INFECTED_DEL    : res = evalInfectedDelCmd(sys, commandArgs); break;
                case CLONE           : res = evalCloneCmd(sys, commandArgs); break;
                case CLONE_ALL       : res = evalCloneAllCmd(sys, commandArgs); break;
                case RATING_IS       : res = evalRatingIsCmd(sys, commandArgs); break;
                case NOP             : break;
                case INVALID_COMMAND : 
                    logError(WARNING, "Failed to parse command [Could be due to an invalid number of args].");
                    res = false;
                    break;
            }

            if (!res) {
                logError(WARNING, "Skipping command '" + command + "'");
                logError(WARNING, "");
            }
        }
    }   

private:
    /*
        Each of the following 'eval*' commands extracts the args 
        (eg: networkName, deviceName, etc.) required for a simulation 
        command and then calls the corresponding method of the System 
        class to execute the command. There is one 'eval*' command 
        corresponding to each of the 9 types of commands
    */

    bool evalNetworkNewCmd(const Ptr<System> sys, const vector<string>& args) {
        const string& networkName = evalNetworkName(args[2]);
        return sys->networkNew(networkName);
    }

    bool evalPersonalNewCmd(const Ptr<System> sys, const vector<string>& args) {
        const string& networkName = evalNetworkName(args[1]);
        const string& deviceName = evalDeviceName(args[3]);
        return sys->personalNew(networkName, deviceName);
    }

    bool evalFirewallNewCmd(const Ptr<System> sys, const vector<string>& args) {
        const string& networkName = evalNetworkName(args[1]);
        const string& deviceName = evalDeviceName(args[3]);
        return sys->firewallNew(networkName, deviceName);
    }

    bool evalConnectionIsCmd(const Ptr<System> sys, const vector<string>& args) {
        const string& networkName = evalNetworkName(args[1]);
        const string& device1Name = evalDeviceName(args[2]);
        const U32 device1Port = evalDevicePort(args[3]);
        const string& device2Name = evalDeviceName(args[5]);
        const U32 device2Port = evalDevicePort(args[6]);
        return sys->connectionIs(networkName, device1Name, device1Port, device2Name, device2Port);
    }

    bool evalInfectionIsCmd(const Ptr<System> sys, const vector<string>& args) {
        const string& networkName = evalNetworkName(args[1]);
        const MalwareStrength& infectionStrength = evalMalwareStrength(args[3]);
        const string& deviceName = evalDeviceName(args[4]);
        const auto ports = evalDevicePorts(args, 5);
        return sys->infectionIs(networkName, infectionStrength, deviceName, ports);
    }

    bool evalInfectedDelCmd(const Ptr<System> sys, const vector<string>& args) {
        const string& networkName = evalNetworkName(args[1]);
        return sys->infectedDel(networkName);
    }

    bool evalCloneCmd(const Ptr<System> sys, const vector<string>& args) {
        const string& networkName = evalNetworkName(args[1]);
        const string& device1Name = evalDeviceName(args[2]);
        const U32 device1Port = evalDevicePort(args[3]);
        const string& device2Name = evalDeviceName(args[5]);
        const U32 device2Port = evalDevicePort(args[6]);
        return sys->clone(networkName, device1Name, device1Port, device2Name, device2Port);
    }

    bool evalCloneAllCmd(const Ptr<System> sys, const vector<string>& args) {
        const string& networkName = evalNetworkName(args[1]);
        const U32 p1 = evalDevicePort(args[3]);
        const U32 p2 = evalDevicePort(args[4]);
        return sys->cloneAll(networkName, p1, p2);
    }

    bool evalRatingIsCmd(const Ptr<System> sys, const vector<string>& args) {
        const string& networkName = evalNetworkName(args[1]);
        const string& deviceName = evalDeviceName(args[2]);
        const U32 p = evalDevicePort(args[3]);
        const MalwareStrength& rating = evalMalwareStrength(args[5]);
        return sys->ratingIs(networkName, deviceName, p, rating);
    }

    // Parse the command, find its type and return a tuple of <CommandType, regex match object>
    const pair<CommandType, std::vector<string>> commandTypeAndArgs(const string& command) {
        std::vector<string> args;
        stringstream cmdStream(command);

        if (command.empty()) {
            return make_pair(NOP, args);
        } else {
            string arg;
            while (cmdStream >> arg) { // Read the words in the command into 'args'
                args.push_back(arg);
            }

            auto numArgs = args.size();
            string cmdClass = args[0];
            if (cmdClass.compare(0, 1, "#") == 0) { // Its a comment
                return make_pair(NOP, args);
            } else if (cmdClass == "Network") {
                if ( (args[1] == "networkNew") && (numArgs == 3)) {
                    return make_pair(NETWORK_NEW, args);
                } else if ( (args[2] == "personalNew") && (numArgs == 4)) {
                    return make_pair(PERSONAL_NEW, args);
                } else if ( (args[2] == "firewallNew") && (numArgs == 4)) {
                    return make_pair(FIREWALL_NEW, args);
                } else if (args[2] == "infectionIs") {
                    return make_pair(INFECTION_IS, args);
                } else if ( (args[2] == "infectedDel") && (numArgs == 3)) {
                    return make_pair(INFECTED_DEL, args);
                } else if ( (args[2] == "cloneAll") && (numArgs == 5)) {
                    return make_pair(CLONE_ALL, args);
                } 
            } else if (cmdClass == "Device") {
                auto cmdName = args[4];
                if ( (args[4] == "connectionIs") && (numArgs == 7)) {
                    return make_pair(CONNECTION_IS, args);
                } else if ( (args[4] == "clone") && (numArgs == 7)) {
                    return make_pair(CLONE, args);
                } else if ( (args[4] == "ratingIs") && (numArgs == 6)) {
                    return make_pair(RATING_IS, args);
                }
            }
        }

        return make_pair(INVALID_COMMAND, args);
    }

    // ==================================
    //  Helper functions
    // ==================================

    const string& evalNetworkName(const string& arg) {
        return arg;
    }

    const string& evalDeviceName(const string& arg) {
        return arg;
    }

    const U32 evalDevicePort(const string& arg) {
        int port = stoi(arg);
        return port;
    }

    const vector<U32> evalDevicePorts(const vector<string>& args, const unsigned int startIndex) {
        vector<U32> ports;
        for (auto i = startIndex; i < args.size(); i++) {
            auto p = args[i];
            ports.push_back(evalDevicePort(p));
        }

        return ports;
    }

    const MalwareStrength& evalMalwareStrength(const string& arg) {
        const double strength = stod(arg);
        return *(new MalwareStrength(strength));
    }

    MalwareSim() {
        // Nothing else to do.
    }

    ~MalwareSim() {
        // Nothing to do.
    }

};

//
// The main program takes one argument, which is the file name with the rules.
// The rules are then executed and the appropriate statistics are printed
// to the console.
//
int main(int argc, const char* argv[]) {
    if (argc <= 1) {
        cout << "Missing input file" << endl;
        return 1;
    }

    if (argc > 2) {
        cout << "Extraneous arguments after input file" << endl;
        return 1;
    }

    string arg = argv[1];

    const auto sim = MalwareSim::instanceNew();

    if (arg == "-") {
        sim->evalStream(cin);
    } else {
        ifstream input(arg);
        if (input.good()) {
            sim->evalStream(input);
        } else {
            cout << "Error opening " << arg << endl;
        }
    }

    return 0;
}
