//
// Stub for main program for Malware Simulation problem.
//
// Copy this file to main.cxx and then edit it to implement your solution.
//

#include "fwk/fwk.h"

#include "MalwareStrength.h"
#include "Port.h"
#include "Device.h"
#include "Network.h"
#include "Commands.h"

#include <iostream>
#include <fstream>
#include <sstream>
#include <queue>
#include <regex>
#include <unordered_map>
#include <utility>
#include <vector>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ifstream;
using std::ostream;
using std::stringstream;

using std::queue;
using std::unordered_map;
using std::vector;

using std::to_string;

using std::make_pair;
using std::pair;
using std::regex;
using std::regex_match;
using std::smatch;
using std::stod;
using std::stoi;

using fwk::Ptr;

// ======================================================
//  Helper functions
// ======================================================

bool isPersonalDevice(const Ptr<Device>& device) {
    return (dynamic_cast<PersonalDevice*>(device.ptr()) != null);
}

bool isInfected(const Ptr<Device>& device) {
    return device->health() == "infected";
}

void cloneAllPortRatings(const Ptr<Device> parentDevice, const Ptr<Device> clonedDevice) {
    for (int i = 0; i < clonedDevice->portCount(); i++) {
        auto p = clonedDevice->port(i);
        p.ratingIs(parentDevice->port(i).rating());
    }
}

bool deviceExists(const Ptr<Network> network, const string& deviceName) {
    return (network->device(deviceName));
}

void printInvalidCommand(const string& cmd) {
    cout << "[WARNING] Invalid command: '" << cmd << "'. Skipping" << endl;
}

// ======================================================

class NetworkTracker;

class DeviceTracker : public Device::Notifiee {
public:
    void networkTrackerIs(const Ptr<NetworkTracker>& networkTracker);

private:
    Ptr<NetworkTracker> networkTracker_;
    void onHealth();
};

class NetworkTracker : public Network::Notifiee {
public:
    NetworkTracker() : 
        personalDeviceCount_(0),
        firewallDeviceCount_(0) {
        // Nothing to do
    }

    static NetworkTracker* instanceNew() {
        return new NetworkTracker();
    }

    // TODO: Does this method need to be 'virtual'?
    virtual void onDeviceNew(const Ptr<Device>& device) { 
        addDevice(device);
        changeDeviceCount(device, true);
    }

    // TODO: Does this method need to be 'virtual'?
    virtual void onDeviceDel(const Ptr<Device>&  device) { 
        changeDeviceCount(device, false);
    }

    void onDeviceHealth(const Ptr<Device>& device) {
        auto delta = isInfected(device) ? 1 : -1;
        infectedDeviceCount_ += delta;
    }

    unsigned int personalDeviceCount() {
        return personalDeviceCount_;
    }

    unsigned int firewallDeviceCount() {
        return firewallDeviceCount_;
    }

    unsigned int infectedDeviceCount() {
        return infectedDeviceCount_;
    }

private:
    unsigned int personalDeviceCount_;
    unsigned int firewallDeviceCount_;
    unsigned int infectedDeviceCount_;

    // TODO: Rename function and 'inc' parameter? Should we use a boolean param or use an enum {NEW, DEL}
    void changeDeviceCount(const Ptr<Device>&  device, bool inc) {
        auto delta = inc ? 1 : -1;
        if (isPersonalDevice(device)) {
            personalDeviceCount_ += delta;   
        } else { // For this assignment only two types of devices are used. Hence, we can safely assume that its a FirewallDevice
            firewallDeviceCount_ += delta;
        }
    }

    void addDevice(const Ptr<Device>& device) {
        const Ptr<DeviceTracker> deviceTracker = new DeviceTracker();
        deviceTracker->notifierIs(device);
        deviceTracker->networkTrackerIs(this);
    }
};

void DeviceTracker::networkTrackerIs(const Ptr<NetworkTracker>& networkTracker) {
    networkTracker_ = networkTracker;
}

void DeviceTracker::onHealth() {
    networkTracker_->onDeviceHealth(notifier());
}  

//
// Class for main simulation logic.
//
class MalwareSim : public fwk::PtrInterface {
public:

    static Ptr<MalwareSim> instanceNew() {
        return new MalwareSim();
    }

    //
    // Read data in, parse it, excute commands.
    //
    void evalStream(istream& input) {
        string line;
        while(getline(input, line)) {
            auto typeAndArgs = commandTypeAndArgs(line);
            auto commandType = typeAndArgs.first;
            auto commandArgs = typeAndArgs.second;

            switch(commandType) {
                case NETWORK_NEW     : evalNetworkNewCmd(commandArgs); break;
                case PERSONAL_NEW    : evalPersonalNewCmd(commandArgs); break;
                case FIREWALL_NEW    : evalFirewallNewCmd(commandArgs); break;
                case CONNECTION_IS   : evalConnectionIsCmd(commandArgs); break;
                case INFECTION_IS    : evalInfectionIsCmd(commandArgs); break;
                case INFECTED_DEL    : evalInfectedDelCmd(commandArgs); break;
                case CLONE           : evalCloneCmd(commandArgs); break;
                case CLONE_ALL       : evalCloneAllCmd(commandArgs); break;
                case RATING_IS       : evalRatingIsCmd(commandArgs); break;
                case NOP             : break;
                case INVALID_COMMAND : printInvalidCommand(line); break;
            }
        }

        printStatistics();
    }   

private:
    typedef unordered_map< string, Ptr<Network> > NetworkMap;
    typedef pair< Ptr<Device>, U32 > DevicePortPair;

    NetworkMap networkMap_;

    // TODO: Can the regexes be initialized at the time of definition itself?
    static regex regexNetworkNew;
    static regex regexPersonalNew;
    static regex regexFirewallNew;
    static regex regexConnectionIs;
    static regex regexInfectionIs;
    static regex regexInfectedDel;
    static regex regexClone;
    static regex regexCloneAll;
    static regex regexRatingIs;

    static regex regexValidNetworkName;
    static regex regexValidDeviceName;

    void printStatistics() {
        auto n = network("network-1");
        auto notifiee = (NetworkTracker*)(n->notifiees().front());
        cout << "Personal Device count: " << notifiee->personalDeviceCount() << endl;
        cout << "Firewall Device count: " << notifiee->personalDeviceCount() << endl;
    }

    void evalNetworkNewCmd(const smatch& args) {
        const string& networkName = evalNetworkName(args[1]);
        networkNew(networkName);
    }

    void evalPersonalNewCmd(const smatch& args) {
        const string& networkName = evalNetworkName(args[1]);
        const string& deviceName = evalDeviceName(args[2]);
        personalNew(networkName, deviceName);
    }

    void evalFirewallNewCmd(const smatch& args) {
        const string& networkName = evalNetworkName(args[1]);
        const string& deviceName = evalDeviceName(args[2]);
        firewallNew(networkName, deviceName);
    }

    void evalConnectionIsCmd(const smatch& args) {
        const string& networkName = evalNetworkName(args[1]);
        const string& device1Name = evalDeviceName(args[2]);
        const U32 device1Port = evalDevicePort(args[3]);
        const string& device2Name = evalDeviceName(args[4]);
        const U32 device2Port = evalDevicePort(args[5]);
        connectionIs(networkName, device1Name, device1Port, device2Name, device2Port);
    }

    void evalInfectionIsCmd(const smatch& args) {
        throw fwk::NoImplementationException("evalInfectionIsCmd");
    }

    void evalInfectedDelCmd(const smatch& args) {
        const string& networkName = evalNetworkName(args[1]);
        infectedDel(networkName);
    }

    void evalCloneCmd(const smatch& args) {
        const string& networkName = evalNetworkName(args[1]);
        const string& device1Name = evalDeviceName(args[2]);
        const U32 device1Port = evalDevicePort(args[3]);
        const string& device2Name = evalDeviceName(args[4]);
        const U32 device2Port = evalDevicePort(args[5]);
        clone(networkName, device1Name, device1Port, device2Name, device2Port);
    }

    void evalCloneAllCmd(const smatch& args) {
        const string& networkName = evalNetworkName(args[1]);
        const U32 p1 = evalDevicePort(args[2]);
        const U32 p2 = evalDevicePort(args[3]);
        cloneAll(networkName, p1, p2);
    }

    void evalRatingIsCmd(const smatch& args) {
        const string& networkName = evalNetworkName(args[1]);
        const string& deviceName = evalDeviceName(args[2]);
        const U32 p = evalDevicePort(args[3]);
        const MalwareStrength& rating = evalMalwareStrength(args[4]);
        ratingIs(networkName, deviceName, p, rating);
    }

    // TODO: Throw an exception or warning if a network with the given name has not been instantiated
    Ptr<Network> network(const string& name) {
        return networkMap_.find(name)->second;
    }

    // Executes a networkNew command
    void networkNew(const string& name) { 
        if (networkMap_.find(name) == networkMap_.end()) {
            auto network = Network::instanceNew(name);
            auto notifiee = NetworkTracker::instanceNew();
            notifiee->notifierIs(network);
            networkMap_.insert(NetworkMap::value_type(name, network));
        } else {
            throw fwk::NameInUseException(name);
        }
    }

    // Executes a personalNew command
    void personalNew(const string& networkName, const string& deviceName) { 
        auto device = PersonalDevice::instanceNew(deviceName);
        auto n = network(networkName); // TODO: Rename this variable
        try {
            n->deviceIs(device);
        } catch (const fwk::NameInUseException& e) {
            cout << "WARNING: PersonalDevice '" << deviceName << "' already in use in network '" << networkName << "'" << endl;
        }
    }

    // Executes a firewallNew command
    void firewallNew(const string& networkName, const string& deviceName) { 
        auto device = FirewallDevice::instanceNew(deviceName);
        auto n = network(networkName);
        try {
            n->deviceIs(device); // TODO: Rename this variable
        } catch (const fwk::NameInUseException& e) {
            cout << "WARNING: FirewallDevice '" << deviceName << "' already in use in network '" << networkName << "'" << endl;
        }
    }

    // Executes a connectionIs command
    void connectionIs(const string& networkName, 
                      const string& device1Name, 
                      const U32 device1Port, 
                      const string& device2Name, 
                      const U32 device2Port) { 
        auto n = network(networkName); // TODO: Rename this variable
        auto device1 = n->device(device1Name); // TODO: Check if returned device is null, ie, such a device has not been instantiated
        auto device2 = n->device(device2Name);
        device1->connectionIs(device1Port, device2, device2Port);
    }

    void infectionIs(const string& networkName,
                     const MalwareStrength& infectionStrength,
                     const string& deviceName,
                     const U32 port) {
        auto n = network(networkName); // TODO: Rename this variable
        auto device = n->device(deviceName); // TODO: Check if returned device is null, ie, such a device has not been instantiated
        queue<DevicePortPair> devicePortPairsToAttack;
        infectDevice(device, port, infectionStrength, devicePortPairsToAttack);

        while (!devicePortPairsToAttack.empty()) {
            auto p = devicePortPairsToAttack.front();
            auto device = p.first;
            infectDevice(device, p.second, infectionStrength, devicePortPairsToAttack);
            devicePortPairsToAttack.pop();
        }
    }

    void infectDevice(const Ptr<Device>& device,
                      const U32 portId, 
                      const MalwareStrength& infectionStrength,
                      queue<DevicePortPair> devicePortPairsToAttack) {
        if (!isInfected(device)) { // Dont revisit a device thats already infected
            auto port = device->port(portId);
            if (port.rating() >= infectionStrength) { // The infection fails immediately
                return; 
            }

            device->healthIs("infected");
            for (U32 i = 0; i < device->portCount(); i++) {
                if ((i != portId) && (!(device->availablePort(i)))) { // Port is connected to another device
                    auto port = device->port(i);
                    DevicePortPair p = make_pair(port.otherDevice(), port.otherPort());
                    devicePortPairsToAttack.push(p);
                }
            }
        }
    }

    void infectedDel(const string& networkName) {
        auto n = network(networkName); // TODO: Rename this variable
        for (auto it = n->deviceIter(); it != n->deviceIterEnd(); it++) {
            auto device = it->second;
            if (isInfected(device)) {
                n->deviceDel(it);
            }
        }
    }

    Ptr<Device> clone(const string& networkName,
               const string& device1Name,
               const U32 device1Port,
               const string& device2Name,
               const U32 device2Port) {
        auto n = this->network(networkName); // TODO: Rename this variable
        auto device1 = n->device(device1Name);

        if (device1->availablePort(device1Port)) {
            Ptr<Device> clonedDevice;
            if (isPersonalDevice(device1)) {
                clonedDevice = PersonalDevice::instanceNew(device2Name);
            } else {
                clonedDevice = FirewallDevice::instanceNew(device2Name);
            }

            auto port1 = device1->port(device1Port);
            auto device2 = n->device(device2Name);
            cloneAllPortRatings(device1, device2);
            port1.connectionIs(device2, device2Port);

            return clonedDevice;
        } 
        
        // TODO: Ignore the command and return a warning. 
        return NULL;
    }

    // TODO: Refactor this function
    void cloneAll(const string& networkName,
                  const U32 p1,
                  const U32 p2) {
        auto n = network(networkName);
        unordered_map< string, Ptr<Device> > parentNameToClone;

        for (auto it = n->deviceIter(); it != n->deviceIterEnd(); it++) {
            auto parentName = it->first;
            auto cloneName = parentName + "-" + to_string(p1);
            if (!deviceExists(n, cloneName)) {
                auto clonedDevice = clone(networkName, parentName, p1, cloneName, p2);
                if (clonedDevice) { // Cloning was successful
                    parentNameToClone[parentName] = clonedDevice;
                } else {
                    // TOOD: Print warning
                }
            } else {
                // TOOD: Print warning that a device of that name already exists. Hence, not cloning parent.
            }
        }

        for (auto it = parentNameToClone.cbegin(); it != parentNameToClone.cend(); it++) {
            auto parent = n->device(it->first);
            auto clonedDevice = it->second;
            for (int p3 = 0; p3 < parent->portCount(); p3++) {
                if (p3 != p1) { // Port 'p1' of the parent is already in use. Its been connected to the clone
                    auto parentPort = parent->port(p3);

                    auto otherDevice = parentPort.otherDevice();
                    auto otherClone = parentNameToClone[otherDevice->name()];
                    auto p4 = parentPort.otherPort();
                    
                    if (clonedDevice->availablePort(p3) && otherClone->availablePort(p4)) {
                        clonedDevice->connectionIs(p3, otherClone, p4);
                    } else {
                        // TODO: Print warning and skip this connection
                    }
                }
            }
        }        
    }

    void ratingIs(const string& networkName,
                  const string& deviceName,
                  const U32 p,
                  const MalwareStrength& rating) {
        auto n = network(networkName);
        auto device = n->device(deviceName);
        device->portRatingIs(p, rating);
    }

    // Parse the command, find its type and return a tuple of <CommandType, regex match object>
    const pair<CommandType, smatch> commandTypeAndArgs(const string& command) {
        smatch baseMatch;

        if (command.empty() || (command[0] == '#')) {
            return make_pair(NOP, baseMatch);
        } else if (regex_match(command, baseMatch, regexNetworkNew)) {
            return make_pair(NETWORK_NEW, baseMatch);
        } else if (regex_match(command, baseMatch, regexPersonalNew)) {
            return make_pair(PERSONAL_NEW, baseMatch);
        } else if (regex_match(command, baseMatch, regexFirewallNew)) {
            return make_pair(FIREWALL_NEW, baseMatch);
        } else if (regex_match(command, baseMatch, regexConnectionIs)) {
            return make_pair(CONNECTION_IS, baseMatch);
        } else if (regex_match(command, baseMatch, regexInfectionIs)) {
            return make_pair(INFECTION_IS, baseMatch);
        } else if (regex_match(command, baseMatch, regexInfectedDel)) {
            return make_pair(INFECTED_DEL, baseMatch);
        } else if (regex_match(command, baseMatch, regexClone)) {
            return make_pair(CLONE, baseMatch);
        } else if (regex_match(command, baseMatch, regexCloneAll)) {
            return make_pair(CLONE_ALL, baseMatch);
        } else if (regex_match(command, baseMatch, regexRatingIs)) {
            return make_pair(RATING_IS, baseMatch);
        }

        return make_pair(INVALID_COMMAND, baseMatch);
    }

    // ==================================
    //  Helper functions
    // ==================================

    const string& evalNetworkName(const string& arg) {
        verifyNetworkName(arg);
        return arg;
    }

    const string& evalDeviceName(const string& arg) {
        verifyDeviceName(arg);
        return arg;
    }

    const int evalDevicePort(const string& arg) {
        int port = stoi(arg);
        if (port < 0) throw fwk::RangeException(arg);
        return port;
    }

    const MalwareStrength& evalMalwareStrength(const string& arg) {
        const double strength = stod(arg);
        return *(new MalwareStrength(strength));
    }

    // TOOD: Fix the regex check. Its broken
    void verifyNetworkName(const string& name) {
        if ((name == "networkNew") || (regex_match(name, regexValidNetworkName))) {
            throw fwk::IllegalNameException(name);
        }
    }

    // TOOD: Fix the regex check. Its broken
    void verifyDeviceName(const string& name) {
        if ((name == "personalNew") || (name == "firewallNew") || (regex_match(name, regexValidNetworkName))) {
            throw fwk::IllegalNameException(name);
        }
    }

    MalwareSim() {
        // Nothing else to do.
    }

    ~MalwareSim() {
        // Nothing to do.
    }

};

// Initialize all the regexes used to parse and identify the type of a given command
regex MalwareSim::regexNetworkNew = regex("Network networkNew (.*)");
regex MalwareSim::regexPersonalNew = regex("Network (.*) personalNew (.*)");
regex MalwareSim::regexFirewallNew = regex("Network (.*) firewallNew (.*)");
regex MalwareSim::regexConnectionIs = regex("Device (.*) (.*) (.*) connectionIs (.*) (.*)");
regex MalwareSim::regexInfectionIs = regex("Network (.*) infectionIs (.*) device1 (.*) [ports...]"); // TODO: Fix this regex
regex MalwareSim::regexInfectedDel = regex("Network (.*) infectedDel");
regex MalwareSim::regexClone = regex("Device (.*) (.*) (.*) clone (.*) (.*)");
regex MalwareSim::regexCloneAll = regex("Network (.*) cloneAll (.*) (.*)");
regex MalwareSim::regexRatingIs = regex("Device (.*) (.*) (.*) ratingIs (.*)");

//regex MalwareSim::regexValidNetworkName = regex("[^\\s\\'\\\"]");
regex MalwareSim::regexValidNetworkName = regex(R"delimiter([^\s\'\"])delimiter");
regex MalwareSim::regexValidDeviceName = regex(R"delimiter([^\s\'\"])delimiter");


//
// The main program takes one argument, which is the file name with the rules.
// The rules are then executed and the appropriate statistics are printed
// to the console.
//
int main(int argc, const char* argv[]) {
    if (argc <= 1) {
        cout << "Missing input file" << endl;
        return 1;
    }

    if (argc > 2) {
        cout << "Extraneous arguments after input file" << endl;
        return 1;
    }

    string arg = argv[1];

    const auto sim = MalwareSim::instanceNew();

    if (arg == "-") {
        sim->evalStream(cin);
    } else {
        ifstream input(arg);
        if (input.good()) {
            sim->evalStream(input);
        } else {
            cout << "Error opening " << arg << endl;
        }
    }

    return 0;
}
