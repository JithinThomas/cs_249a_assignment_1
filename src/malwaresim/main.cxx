//
// Stub for main program for Malware Simulation problem.
//
// Copy this file to main.cxx and then edit it to implement your solution.
//

#include "fwk/fwk.h"

#include "MalwareStrength.h"
#include "Port.h"
#include "Device.h"
#include "Network.h"
#include "System.h"

#include <iostream>
#include <fstream>
#include <sstream>
#include <queue>
#include <regex>
#include <set>
#include <tuple>
#include <unordered_map>
#include <utility>
#include <vector>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ifstream;
using std::ostream;
using std::stringstream;

using std::queue;
using std::unordered_map;
using std::vector;

using std::to_string;

using std::list;
using std::make_pair;
using std::make_tuple;
using std::pair;
using std::regex;
using std::regex_match;
using std::set;
using std::smatch;
using std::stod;
using std::stoi;
using std::tuple;

using fwk::Ptr;

//
// Class for main simulation logic.
//
class MalwareSim : public fwk::PtrInterface {
public:

    static Ptr<MalwareSim> instanceNew() {
        return new MalwareSim();
    }

    //
    // Read data in, parse it, excute commands.
    //
    void evalStream(istream& input) {
        auto sys = System::instanceNew("system-1");
        string command;
        while(getline(input, command)) {
            auto typeAndArgs = commandTypeAndArgs(command);
            auto commandType = typeAndArgs.first;
            auto commandArgs = typeAndArgs.second;

            //cout << "[CMD]: (" << getCommandType(commandType) << ") " << command << endl;

            switch(commandType) {
                case NETWORK_NEW     : evalNetworkNewCmd(sys, commandArgs); break;
                case PERSONAL_NEW    : evalPersonalNewCmd(sys, commandArgs); break;
                case FIREWALL_NEW    : evalFirewallNewCmd(sys, commandArgs); break;
                case CONNECTION_IS   : evalConnectionIsCmd(sys, commandArgs); break;
                case INFECTION_IS    : evalInfectionIsCmd(sys, commandArgs); break;
                case INFECTED_DEL    : evalInfectedDelCmd(sys, commandArgs); break;
                case CLONE           : evalCloneCmd(sys, commandArgs); break;
                case CLONE_ALL       : evalCloneAllCmd(sys, commandArgs); break;
                case RATING_IS       : evalRatingIsCmd(sys, commandArgs); break;
                case NOP             : break;
                case INVALID_COMMAND : printInvalidCommand(command, "Unrecognized command"); break;
            }
        }
    }   

private:
    void evalNetworkNewCmd(const Ptr<System> sys, const vector<string>& args) {
        const string& networkName = evalNetworkName(args[2]);
        sys->networkNew(networkName);
    }

    void evalPersonalNewCmd(const Ptr<System> sys, const vector<string>& args) {
        const string& networkName = evalNetworkName(args[1]);
        const string& deviceName = evalDeviceName(args[3]);
        sys->personalNew(networkName, deviceName);
    }

    void evalFirewallNewCmd(const Ptr<System> sys, const vector<string>& args) {
        const string& networkName = evalNetworkName(args[1]);
        const string& deviceName = evalDeviceName(args[3]);
        sys->firewallNew(networkName, deviceName);
    }

    void evalConnectionIsCmd(const Ptr<System> sys, const vector<string>& args) {
        const string& networkName = evalNetworkName(args[1]);
        const string& device1Name = evalDeviceName(args[2]);
        const U32 device1Port = evalDevicePort(args[3]);
        const string& device2Name = evalDeviceName(args[5]);
        const U32 device2Port = evalDevicePort(args[6]);
        sys->connectionIs(networkName, device1Name, device1Port, device2Name, device2Port);
    }

    void evalInfectionIsCmd(const Ptr<System> sys, const vector<string>& args) {
        const string& networkName = evalNetworkName(args[1]);
        const MalwareStrength& infectionStrength = evalMalwareStrength(args[3]);
        const string& deviceName = evalDeviceName(args[4]);
        const auto ports = evalDevicePorts(args, 5);
        sys->infectionIs(networkName, infectionStrength, deviceName, ports);
    }

    void evalInfectedDelCmd(const Ptr<System> sys, const vector<string>& args) {
        const string& networkName = evalNetworkName(args[1]);
        sys->infectedDel(networkName);
    }

    void evalCloneCmd(const Ptr<System> sys, const vector<string>& args) {
        const string& networkName = evalNetworkName(args[1]);
        const string& device1Name = evalDeviceName(args[2]);
        const U32 device1Port = evalDevicePort(args[3]);
        const string& device2Name = evalDeviceName(args[5]);
        const U32 device2Port = evalDevicePort(args[6]);
        sys->clone(networkName, device1Name, device1Port, device2Name, device2Port);
    }

    void evalCloneAllCmd(const Ptr<System> sys, const vector<string>& args) {
        const string& networkName = evalNetworkName(args[1]);
        const U32 p1 = evalDevicePort(args[3]);
        const U32 p2 = evalDevicePort(args[4]);
        sys->cloneAll(networkName, p1, p2);
    }

    void evalRatingIsCmd(const Ptr<System> sys, const vector<string>& args) {
        const string& networkName = evalNetworkName(args[1]);
        const string& deviceName = evalDeviceName(args[2]);
        const U32 p = evalDevicePort(args[3]);
        const MalwareStrength& rating = evalMalwareStrength(args[5]);
        sys->ratingIs(networkName, deviceName, p, rating);
    }

    // Parse the command, find its type and return a tuple of <CommandType, regex match object>
    const pair<CommandType, std::vector<string>> commandTypeAndArgs(const string& command) {
        std::vector<string> args;
        stringstream cmdStream(command);

        if (command.empty() || (command[0] == '#')) {
            return make_pair(NOP, args);
        } else {
            string arg;
            while (cmdStream >> arg) {
                args.push_back(arg);
            }

            string cmdClass = args[0];
            if (cmdClass == "Network") {
                if (args[1] == "networkNew") {
                    if (args.size() == 3) {
                        return make_pair(NETWORK_NEW, args);
                    } else {
                        printInvalidCommand(command, "Invalid name specified for network");
                    }
                } else if (args[2] == "personalNew") {
                    if (args.size() == 4) {
                        return make_pair(PERSONAL_NEW, args);
                    } else {
                        printInvalidCommand(command, "Invalid name specified for device");   
                    }
                } else if (args[2] == "firewallNew") {
                    if (args.size() == 4) {
                        return make_pair(FIREWALL_NEW, args);
                    } else {
                        printInvalidCommand(command, "Invalid name specified for device");   
                    }
                } else if (args[2] == "infectionIs") {
                    return make_pair(INFECTION_IS, args);
                } else if (args[2] == "infectedDel") {
                    return make_pair(INFECTED_DEL, args);
                } else if (args[2] == "cloneAll") {
                    return make_pair(CLONE_ALL, args);
                }
            } else if (cmdClass == "Device") {
                auto cmdName = args[4];
                if (cmdName == "connectionIs") {
                    return make_pair(CONNECTION_IS, args);
                } else if (cmdName == "clone") {
                    return make_pair(CLONE, args);
                } else if (cmdName == "ratingIs") {
                    return make_pair(RATING_IS, args);
                }
            }
        }

        return make_pair(INVALID_COMMAND, args);
    }

    // ==================================
    //  Helper functions
    // ==================================

    const string& evalNetworkName(const string& arg) {
        verifyNetworkName(arg);
        return arg;
    }

    const string& evalDeviceName(const string& arg) {
        verifyDeviceName(arg);
        return arg;
    }

    const U32 evalDevicePort(const string& arg) {
        int port = stoi(arg);
        if (port < 0) throw fwk::RangeException(arg);
        return port;
    }

    const vector<U32> evalDevicePorts(const vector<string>& args, const int startIndex) {
        vector<U32> ports;
        for (auto i = startIndex; i < args.size(); i++) {
            auto p = args[i];
            ports.push_back(evalDevicePort(p));
        }

        return ports;
    }

    const MalwareStrength& evalMalwareStrength(const string& arg) {
        const double strength = stod(arg);
        return *(new MalwareStrength(strength));
    }

    // TOOD: Fix the regex check. Its broken
    void verifyNetworkName(const string& name) {
        if (name == "networkNew") {
            throw fwk::IllegalNameException(name);
        }
    }

    // TOOD: Fix the regex check. Its broken
    void verifyDeviceName(const string& name) {
        if ((name == "personalNew") || (name == "firewallNew")) {
            throw fwk::IllegalNameException(name);
        }
    }

    MalwareSim() {
        // Nothing else to do.
    }

    ~MalwareSim() {
        // Nothing to do.
    }

};

//
// The main program takes one argument, which is the file name with the rules.
// The rules are then executed and the appropriate statistics are printed
// to the console.
//
int main(int argc, const char* argv[]) {
    if (argc <= 1) {
        cout << "Missing input file" << endl;
        return 1;
    }

    if (argc > 2) {
        cout << "Extraneous arguments after input file" << endl;
        return 1;
    }

    string arg = argv[1];

    const auto sim = MalwareSim::instanceNew();

    if (arg == "-") {
        sim->evalStream(cin);
    } else {
        ifstream input(arg);
        if (input.good()) {
            sim->evalStream(input);
        } else {
            cout << "Error opening " << arg << endl;
        }
    }

    return 0;
}
