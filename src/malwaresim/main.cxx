//
// Stub for main program for Malware Simulation problem.
//
// Copy this file to main.cxx and then edit it to implement your solution.
//

#include "fwk/fwk.h"

#include "MalwareStrength.h"
#include "Port.h"
#include "Device.h"
#include "Network.h"
#include "Commands.h"

#include <iostream>
#include <fstream>
#include <sstream>
#include <queue>
#include <regex>
#include <unordered_map>
#include <utility>
#include <vector>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ifstream;
using std::ostream;
using std::stringstream;

using std::queue;
using std::unordered_map;
using std::vector;

using std::to_string;

using std::make_pair;
using std::pair;
using std::regex;
using std::regex_match;
using std::smatch;
using std::stoi;

using fwk::Ptr;

class NetworkNotifiee : public Network::Notifiee {
public:
    NetworkNotifiee() : deviceCount_(0) {
        // Nothing to do
    }

    static NetworkNotifiee* instanceNew() {
        return new NetworkNotifiee();
    }

    virtual void onDeviceNew(const Ptr<Device>& device) { 
        deviceCount_++;
    }

    virtual void onDeviceDel(const Ptr<Device>&  device) { 
        deviceCount_--;
    }

    unsigned int deviceCount() {
        return deviceCount_;
    }

private:
    unsigned int deviceCount_;
};

//
// Class for main simulation logic.
//
class MalwareSim : public fwk::PtrInterface {
public:

    static Ptr<MalwareSim> instanceNew() {
        return new MalwareSim();
    }


    //
    // Read data in, parse it, excute commands.
    //
    void evalStream(istream& input) {
        string line;
        while(getline(input, line)) {
            auto typeAndArgs = commandTypeAndArgs(line);
            auto commandType = typeAndArgs.first;
            auto commandArgs = typeAndArgs.second;

            switch(commandType) {
                case NETWORK_NEW   : evalNetworkNewCmd(commandArgs); break;
                case PERSONAL_NEW  : evalPersonalNewCmd(commandArgs); break;
                case FIREWALL_NEW  : evalFirewallNewCmd(commandArgs); break;
                case CONNECTION_IS : evalConnectionIsCmd(commandArgs); break;
                case INFECTED_DEL  : evalInfectedDelCmd(commandArgs); break;
            }
        }

        printStatistics();
    }   

private:
    typedef unordered_map< string, Ptr<Network> > NetworkMap;
    typedef pair< Ptr<Device>, U32 > DevicePortPair;
    typedef unordered_map< string>

    NetworkMap networkMap_;

    // TODO: Can the regexes be initialized at the time of definition itself?
    static regex regexNetworkNew;
    static regex regexPersonalNew;
    static regex regexFirewallNew;
    static regex regexConnectionIs;
    static regex regexInfectionIs;
    static regex regexInfectedDel;
    static regex regexClone;
    static regex regexCloneAll;
    static regex regexRatingIs;

    static regex regexValidNetworkName;
    static regex regexValidDeviceName;

    void printStatistics() {
        auto n = network("network-1");
        auto notifiee = (NetworkNotifiee*)(n->notifiees().front());
        cout << "Device count: " << notifiee->deviceCount() << endl;
    }

    void evalNetworkNewCmd(const smatch& args) {
        string networkName = evalNetworkName(args[1]);
        networkNew(networkName);
    }

    void evalPersonalNewCmd(const smatch& args) {
        string networkName = evalNetworkName(args[1]);
        string deviceName = evalDeviceName(args[2]);
        personalNew(networkName, deviceName);
    }

    void evalFirewallNewCmd(const smatch& args) {
        string networkName = evalNetworkName(args[1]);
        string deviceName = evalDeviceName(args[2]);
        firewallNew(networkName, deviceName);
    }

    void evalConnectionIsCmd(const smatch& args) {
        string networkName = evalNetworkName(args[1]);
        string device1Name = evalDeviceName(args[2]);
        int device1Port = evalDevicePort(args[3]);
        string device2Name = evalDeviceName(args[4]);
        int device2Port = evalDevicePort(args[5]);
        connectionIs(networkName, device1Name, device1Port, device2Name, device2Port);
    }

    void evalInfectionIsCmd(const smatch& args) {
        throw fwk::NoImplementationException("evalInfectionIsCmd");
    }

    void evalInfectedDelCmd(const smatch& args) {
        const string& networkName = evalNetworkName(args[1]);
        infectedDel(networkName);
    }

    void evalCloneCmd(const smatch& args) {
        throw fwk::NoImplementationException("evalCloneCmd");
    }

    void evalCloneAllCmd(const smatch& args) {
        throw fwk::NoImplementationException("evalCloneAllCmd");
    }

    void evalRatingIsCmd(const smatch& args) {
        throw fwk::NoImplementationException("evalRatingIsCmd");
    }

    // TODO: Throw an exception or warning if a network with the given name has not been instantiated
    Ptr<Network> network(const string& name) {
        return networkMap_.find(name)->second;
    }

    // Executes a networkNew command
    void networkNew(const string& name) { 
        if (networkMap_.find(name) == networkMap_.end()) {
            auto network = Network::instanceNew(name);
            auto notifiee = NetworkNotifiee::instanceNew();
            notifiee->notifierIs(network);
            networkMap_.insert(NetworkMap::value_type(name, network));
        } else {
            throw fwk::NameInUseException(name);
        }
    }

    // Executes a personalNew command
    void personalNew(const string& networkName, const string& deviceName) { 
        auto device = PersonalDevice::instanceNew(deviceName);
        auto n = network(networkName); // TODO: Rename this variable
        try {
            n->deviceIs(device);
        } catch (const fwk::NameInUseException& e) {
            cout << "WARNING: PersonalDevice '" << deviceName << "' already in use in network '" << networkName << "'" << endl;
        }
    }

    // Executes a firewallNew command
    void firewallNew(const string& networkName, const string& deviceName) { 
        auto device = FirewallDevice::instanceNew(deviceName);
        auto n = network(networkName);
        try {
            n->deviceIs(device); // TODO: Rename this variable
        } catch (const fwk::NameInUseException& e) {
            cout << "WARNING: FirewallDevice '" << deviceName << "' already in use in network '" << networkName << "'" << endl;
        }
    }

    // Executes a connectionIs command
    void connectionIs(const string& networkName, 
                      const string& device1Name, 
                      const U32 device1Port, 
                      const string& device2Name, 
                      const U32 device2Port) { 
        auto n = network(networkName); // TODO: Rename this variable
        auto device1 = n->device(device1Name); // TODO: Check if returned device is null, ie, such a device has not been instantiated
        auto device2 = n->device(device2Name);
        device1->connectionIs(device1Port, device2, device2Port);
    }

    void infectionIs(const string& networkName,
                     const MalwareStrength& infectionStrength,
                     const string& deviceName,
                     const U32 port) {
        auto n = network(networkName); // TODO: Rename this variable
        auto device = n->device(deviceName); // TODO: Check if returned device is null, ie, such a device has not been instantiated
        queue<DevicePortPair> devicePortPairsToAttack;
        infectDevice(device, port, infectionStrength, devicePortPairsToAttack);

        while (!devicePortPairsToAttack.empty()) {
            auto p = devicePortPairsToAttack.front();
            auto device = p.first;
            infectDevice(device, p.second, infectionStrength, devicePortPairsToAttack);
            devicePortPairsToAttack.pop();
        }
    }

    void infectDevice(const Ptr<Device>& device,
                      const U32 portId, 
                      const MalwareStrength& infectionStrength,
                      queue<DevicePortPair> devicePortPairsToAttack) {
        if (!isInfected(device)) { // Dont revisit a device thats already infected
            auto port = device->port(portId);
            if (port.rating() >= infectionStrength) { // The infection fails immediately
                return; 
            }

            device->healthIs("infected");
            for (U32 i = 0; i < device->portCount(); i++) {
                if ((i != portId) && (!(device->availablePort(i)))) { // Port is connected to another device
                    auto port = device->port(i);
                    DevicePortPair p = make_pair(port.otherDevice(), port.otherPort());
                    devicePortPairsToAttack.push(p);
                }
            }
        }
    }

    void infectedDel(const string& networkName) {
        auto n = network(networkName); // TODO: Rename this variable
        for (auto it = n->deviceIter(); it != n->deviceIterEnd(); it++) {
            auto device = it->second;
            if (isInfected(device)) {
                n->deviceDel(it);
            }
        }
    }

    bool isInfected(const Ptr<Device>& device) {
        return device->health() == "infected";
    }

    // Parse the command, find its type and return a tuple of <CommandType, regex match object>
    pair<CommandType, smatch> commandTypeAndArgs(const string& command) {
        smatch baseMatch;

        if (command.empty() || (command[0] == '#')) {
            return make_pair(NOP, baseMatch);
        } else if (regex_match(command, baseMatch, regexNetworkNew)) {
            return make_pair(NETWORK_NEW, baseMatch);
        } else if (regex_match(command, baseMatch, regexPersonalNew)) {
            return make_pair(PERSONAL_NEW, baseMatch);
        } else if (regex_match(command, baseMatch, regexFirewallNew)) {
            return make_pair(FIREWALL_NEW, baseMatch);
        } else if (regex_match(command, baseMatch, regexConnectionIs)) {
            return make_pair(CONNECTION_IS, baseMatch);
        } else if (regex_match(command, baseMatch, regexInfectionIs)) {
            return make_pair(INFECTION_IS, baseMatch);
        } else if (regex_match(command, baseMatch, regexInfectedDel)) {
            return make_pair(INFECTED_DEL, baseMatch);
        } else if (regex_match(command, baseMatch, regexClone)) {
            return make_pair(CLONE, baseMatch);
        } else if (regex_match(command, baseMatch, regexCloneAll)) {
            return make_pair(CLONE_ALL, baseMatch);
        } else if (regex_match(command, baseMatch, regexRatingIs)) {
            return make_pair(RATING_IS, baseMatch);
        }

        return make_pair(INVALID_COMMAND, baseMatch);
    }

    // ==================================
    //  Helper functions
    // ==================================

    const string& evalNetworkName(const string& arg) {
        verifyNetworkName(arg);
        return arg;
    }

    const string& evalDeviceName(const string& arg) {
        verifyDeviceName(arg);
        return arg;
    }

    const int evalDevicePort(const string& arg) {
        int port = stoi(arg);
        if (port < 0) throw fwk::RangeException(arg);
        return port;
    }

    // TOOD: Fix the regex check. Its broken
    void verifyNetworkName(const string& name) {
        if ((name == "networkNew") || (regex_match(name, regexValidNetworkName))) {
            throw fwk::IllegalNameException(name);
        }
    }

    // TOOD: Fix the regex check. Its broken
    void verifyDeviceName(const string& name) {
        if ((name == "personalNew") || (name == "firewallNew") || (regex_match(name, regexValidNetworkName))) {
            throw fwk::IllegalNameException(name);
        }
    }

    MalwareSim() {
        // Nothing else to do.
    }

    ~MalwareSim() {
        // Nothing to do.
    }

};

// Initialize all the regexes used to parse and identify the type of a given command
regex MalwareSim::regexNetworkNew = regex("Network networkNew (.*)");
regex MalwareSim::regexPersonalNew = regex("Network (.*) personalNew (.*)");
regex MalwareSim::regexFirewallNew = regex("Network (.*) firewallNew (.*)");
regex MalwareSim::regexConnectionIs = regex("Device (.*) (.*) (.*) connectionIs (.*) (.*)");
regex MalwareSim::regexInfectionIs = regex("Network (.*) infectionIs (.*) device1 (.*) [ports...]"); // TODO: Fix this regex
regex MalwareSim::regexInfectedDel = regex("Network (.*) infectedDel");
regex MalwareSim::regexClone = regex("Device (.*) (.*) (.*) clone (.*) (.*)");
regex MalwareSim::regexCloneAll = regex("Network (.*) cloneAll (.*) (.*)");
regex MalwareSim::regexRatingIs = regex("Device (.*) (.*) (.*) ratingIs (.*)");

//regex MalwareSim::regexValidNetworkName = regex("[^\\s\\'\\\"]");
regex MalwareSim::regexValidNetworkName = regex(R"delimiter([^\s\'\"])delimiter");
regex MalwareSim::regexValidDeviceName = regex(R"delimiter([^\s\'\"])delimiter");

//
// The main program takes one argument, which is the file name with the rules.
// The rules are then executed and the appropriate statistics are printed
// to the console.
//
int main(int argc, const char* argv[]) {
    if (argc <= 1) {
        cout << "Missing input file" << endl;
        return 1;
    }

    if (argc > 2) {
        cout << "Extraneous arguments after input file" << endl;
        return 1;
    }

    string arg = argv[1];

    const auto sim = MalwareSim::instanceNew();

    if (arg == "-") {
        sim->evalStream(cin);
    } else {
        ifstream input(arg);
        if (input.good()) {
            sim->evalStream(input);
        } else {
            cout << "Error opening " << arg << endl;
        }
    }

    return 0;
}
